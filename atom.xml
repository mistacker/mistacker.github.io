<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mistacker|博客</title>
  
  <subtitle>孤帆远影碧空尽，唯见长江天际流。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mistacker.github.io/"/>
  <updated>2018-10-23T14:43:13.791Z</updated>
  <id>https://mistacker.github.io/</id>
  
  <author>
    <name>mistacker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LinkExtractor的简单使用</title>
    <link href="https://mistacker.github.io/2018/10/23/linkextractor/"/>
    <id>https://mistacker.github.io/2018/10/23/linkextractor/</id>
    <published>2018-10-23T14:43:13.903Z</published>
    <updated>2018-10-23T14:43:13.791Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; 在爬取一个网站时，想要爬去的数据同场分布在多个页面中，每个页面包含一部分数据以及通向其他页面的链接；往往想要获取到我们想要的数据，就必须提取链接进行访问，提取链接可使用<code>Selector</code>和<code>LinkExtractor</code>两种方法，我们就后一种方法进行简单的使用说明，至于为什么使用<code>LinkExtractor</code>，当然是因为其在提取大量链接时更加方便。(<em>注：这里所说的爬取是指通过<code>scrapy</code>框架进行操作的，如果没有当然就需要安装了。</em>)</p><h4 id="下载通过一个简单的例子进行演示说明：-这里以起点免费作品页面进行演示"><a href="#下载通过一个简单的例子进行演示说明：-这里以起点免费作品页面进行演示" class="headerlink" title="下载通过一个简单的例子进行演示说明：(这里以起点免费作品页面进行演示)"></a>下载通过一个简单的例子进行演示说明：(这里以起点免费作品页面进行演示)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scrapy shell -s USER_AGENT=<span class="string">"Mozilla/5.0"</span> <span class="string">'https://www.qidian.com/free/all'</span></span></span><br><span class="line">...</span><br><span class="line">2018-10-23 16:08:22 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://www.qidian.com/robots.txt&gt; (referer: None)</span><br><span class="line">2018-10-23 16:08:22 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://www.qidian.com/free/all&gt; (referer: None)</span><br><span class="line">[s] Available Scrapy objects:</span><br><span class="line">[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)</span><br><span class="line">[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x7f0458000390&gt;</span><br><span class="line">[s]   item       &#123;&#125;</span><br><span class="line">[s]   request    &lt;GET https://www.qidian.com/free/all&gt;</span><br><span class="line">[s]   response   &lt;200 https://www.qidian.com/free/all&gt;</span><br><span class="line">[s]   settings   &lt;scrapy.settings.Settings object at 0x7f045694c780&gt;</span><br><span class="line">[s]   spider     &lt;DefaultSpider 'default' at 0x7f04564d3c88&gt;</span><br><span class="line">[s] Useful shortcuts:</span><br><span class="line">[s]   fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)</span><br><span class="line">[s]   fetch(req)                  Fetch a scrapy.Request and update local objects </span><br><span class="line">[s]   shelp()           Shell help (print this help)</span><br><span class="line">[s]   view(response)    View response in a browser</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>我们以翻页为例，获取它的下一页链接，该页面是这样的：<br><img src="/images/qidian.png" alt=""><br>代码获取一下该翻页链接：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le = LinkExtractor(restrict_xpaths=<span class="string">'//div[@id="page-container"]//li[9]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>links = le.extract_links(response)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>links[<span class="number">0</span>].url</span><br><span class="line"><span class="string">'https://www.qidian.com/free/all?orderId=&amp;vip=hidden&amp;style=1&amp;pageSize=20&amp;siteid=1&amp;pubflag=0&amp;hiddenField=1&amp;page=2'</span></span><br></pre></td></tr></table></figure></p><p>获取到的<code>url</code>就是下一页的<code>url</code>，下面我们就可以完成<code>Spider</code>的提取下一页链接的任务。</p><h2 id="简单创建一个爬虫项目："><a href="#简单创建一个爬虫项目：" class="headerlink" title="简单创建一个爬虫项目："></a>简单创建一个爬虫项目：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy startproject qidian</span><br><span class="line">...</span><br><span class="line">$ cd qidian</span><br><span class="line">$ scrapy genspider qidianBook qidian.com</span><br><span class="line">Created spider <span class="string">'qidianBook'</span> using template <span class="string">'basic'</span> <span class="keyword">in</span> module:</span><br><span class="line">  qidian.spiders.qidianBook</span><br></pre></td></tr></table></figure><p>下面我们开始编写<code>spiders</code>中的<code>qidianBook.py</code>，针对这个项目，我们仅仅获取一下所有小说的书名、作者、分类、简介：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QidianbookSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'qidianBook'</span></span><br><span class="line">    allowed_domains = [<span class="string">'qidian.com'</span>]</span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">'https://www.qidian.com/free/all?orderId=&amp;vip=hidden&amp;style=1&amp;pageSize=20&amp;siteid=1&amp;pubflag=0&amp;hiddenField=1&amp;page=1'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        baseUrl = response.url</span><br><span class="line">        book_lis = response.xpath(<span class="string">'//ul[@class="all-img-list cf"]/li'</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> book_lis:</span><br><span class="line">            book_name = li.xpath(<span class="string">'.//h4/a/text()'</span>).extract_first()</span><br><span class="line">            book_author = li.xpath(<span class="string">'.//p[@class="author"]/a[@class="name"]/text()'</span>).extract_first()</span><br><span class="line">            book_type = <span class="string">'*'</span>.join(li.css(<span class="string">'p[class="author"]&gt;a:nth-child(4)::text,a:nth-child(6)::text'</span>).extract())</span><br><span class="line">            item = &#123;</span><br><span class="line">                <span class="string">'书名：'</span>: book_name,</span><br><span class="line">                <span class="string">'作者：'</span>: book_author,</span><br><span class="line">                <span class="string">'类型：'</span>: book_type,</span><br><span class="line">            &#125;</span><br><span class="line">            url = li.css(<span class="string">'h4&gt;a::attr("href")'</span>).extract_first()</span><br><span class="line">            complete_url = urljoin(baseUrl, url)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(complete_url, callback=self.get_intro, meta=&#123;<span class="string">'item'</span>: item&#125;)</span><br><span class="line"></span><br><span class="line">        le = LinkExtractor(restrict_xpaths=<span class="string">'//div[@id="page-container"]//li[9]'</span>)</span><br><span class="line">        links = le.extract_links(response)</span><br><span class="line">        <span class="keyword">if</span> links:</span><br><span class="line">            next_url = links[<span class="number">0</span>].url</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_url, callback=self.parse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_intro</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = response.meta[<span class="string">'item'</span>]</span><br><span class="line">        intro = response.css(<span class="string">'div[class="book-intro"]&gt;p::text'</span>).extract_first().replace(<span class="string">' '</span>, <span class="string">''</span>).replace(<span class="string">'\r'</span>, <span class="string">''</span>).replace(<span class="string">'\u3000'</span>, <span class="string">' '</span>)</span><br><span class="line">        item[<span class="string">'简介：'</span>] = intro</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><p>然后我们执行这个爬虫，执行之前可以在<code>settings</code>中添加一个<code>USER_AGENT</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (X11; Ubuntu; Linu…) Gecko/20100101 Firefox/62.0'</span></span><br></pre></td></tr></table></figure></p><p>执行，并把结果保存到<code>qidian.json</code>中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scrapy crawl qidianBook -o qidian.json -s FEED_EXPORT_ENCODING=utf-8</span></span><br></pre></td></tr></table></figure></p><p>你可得有心理准备，这一运行，就会把所有书爬下来。<br>之后你就可以查看<code>qidian.json</code>文件里的内容了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat qidian.json</span></span><br><span class="line">[</span><br><span class="line">&#123;"书名：": "神级生灵", "作者：": "魔动", "类型：": "玄幻*东方玄幻", "简介：": "  穿越不是神话，这是龙炅的座右铭，也只是座右铭！"&#125;,</span><br><span class="line">&#123;"书名：": "云穹之未来断点", "作者：": "骷髅精灵", "类型：": "科幻*未来世界", "简介：": "  异族入侵太阳系，血狼战队队长莫峰在一场惨烈的会战之后回到了末日之前，他能否解开谜团，改变身边亲人朋友的命运……"&#125;,</span><br><span class="line">&#123;"书名：": "最遥远的南边", "作者：": "哦罗罗", "类型：": "现实*成功励志", "简介：": "  几十个英文单词储备就远赴海外，是头脑发热还是......？"&#125;,</span><br><span class="line">&#123;"书名：": "保持匿名", "作者：": "莫远遥", "类型：": "现实*现实百态", "简介：": "  突然发现至少20个字的介绍不知该说些什么，其实，连作品类型，我也不确切我选对没有，它当然和“玄幻”“奇幻”“武侠”“仙侠”“军事”“历史”“游戏”“体育”“灵异”“女生”“二次元”这类无关，天，完全不入流的啊，还有谁会看，“科幻”的话，应该也不算，那就只剩下都市和职场了，可是，那些奇人神人离奇幻想狗血剧情，我实在不会啊，也罢也罢，怎么说，小说背景也算是在都市吧，那作品类型就选“都市”吧，可是子类“异术超能”“恩怨情仇”“青春校园”……果然，大家都爱看些充满幻想的东西，算了算了，随意选吧，就当，这里是我一个人的菜园子，每天来浇点水松松土种种菜，也就不求有人问津了。"&#125;,</span><br><span class="line">&#123;"书名：": "开天录", "作者：": "血红", "类型：": "玄幻*东方玄幻", "简介：": "  生存，很容易。"&#125;,</span><br><span class="line">&#123;"书名：": "红砖街轶事", "作者：": "李安云", "类型：": "现实*现实百态", "简介：": "  一条闹中取静、建筑独特的老街"&#125;,</span><br><span class="line">......</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><code>LinkExtractor</code>的使用更方便的获取打了下一页的链接，代码简洁，这仅仅是其一种方式的使用，更多参数请参考<a href="https://doc.scrapy.org/en/latest/topics/link-extractors.html" target="_blank" rel="noopener">Link Extractors</a></p>]]></content>
    
    <summary type="html">
    
      在爬取一个网站时，想要爬去的数据同场分布在多个页面中，每个页面包含一部分数据以及通向其他页面的链接；往往想要获取到我们想要的数据，就必须提取链接进行访问。如何访问呢？简单写一个LinkExtractor的使用例子。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
      <category term="scrapy" scheme="https://mistacker.github.io/categories/python/scrapy/"/>
    
    
      <category term="linkextractor" scheme="https://mistacker.github.io/tags/linkextractor/"/>
    
  </entry>
  
  <entry>
    <title>网页爬虫---html的遍历</title>
    <link href="https://mistacker.github.io/2018/10/23/bs4_and_lxml/"/>
    <id>https://mistacker.github.io/2018/10/23/bs4_and_lxml/</id>
    <published>2018-10-23T14:13:43.793Z</published>
    <updated>2018-10-23T14:13:43.749Z</updated>
    
    <content type="html"><![CDATA[<p><strong>index.html页面内容：</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"meta_name"</span> <span class="attr">content</span>=<span class="string">"meta_content"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试html内容<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello everyone!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>今日天气：晴转多云<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>左边标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">            网址一:<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"#link1"</span>&gt;</span>www.example1.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            网址二:<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"#link2"</span>&gt;</span>www.example2.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"end"</span>&gt;</span>底部内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Beautiful-Soup的使用"><a href="#Beautiful-Soup的使用" class="headerlink" title="Beautiful Soup的使用"></a>Beautiful Soup的使用</h2><p><strong>初始化页面</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"index.html"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    html = f.read()</span><br><span class="line">    </span><br><span class="line">soup = BeautifulSoup(html, <span class="string">"html.parser"</span>)</span><br></pre></td></tr></table></figure></p><p><strong>获取h2标签</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h2 = soup.select(<span class="string">"h2"</span>)</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">h2 = soup.find_all(<span class="string">"h2"</span>)</span><br><span class="line">print(h2)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;h2&gt;hello everyone!&lt;/h2&gt;]</span><br></pre></td></tr></table></figure></p><p><strong>获取所有div</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">divs = soup.select(<span class="string">"div"</span>)</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">divs = soup.find_all(<span class="string">"div"</span>)</span><br><span class="line">print(divs)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;div class="content" id="left"&gt;左边标题&lt;/div&gt;, &lt;div class="content" id="right"&gt;</span><br><span class="line">    网址一:&lt;a class="link" href="#link1"&gt;www.example1.com&lt;/a&gt;</span><br><span class="line">    网址二:&lt;a class="link" href="#link2"&gt;www.example2.com&lt;/a&gt;</span><br><span class="line"> &lt;/div&gt;, &lt;div class="end"&gt;底部内容&lt;/div&gt;]</span><br></pre></td></tr></table></figure></p><p><strong>获取class=”content”的div内容</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">divs = soup.find_all(<span class="string">"div"</span>, class_=<span class="string">"content"</span>)<span class="comment"># 获取div id=left的内容</span></span><br><span class="line">text = divs[<span class="number">0</span>].text</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'左边标题'</span></span><br></pre></td></tr></table></figure></p><p><strong>获取网址一的链接内容</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = soup.find_all(<span class="string">"a"</span>, class_=<span class="string">"link"</span>)</span><br><span class="line">href = a[<span class="number">0</span>][<span class="string">"href"</span>]<span class="comment"># 获取meta 属性content的值</span></span><br><span class="line">print(href)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'#link1'</span></span><br></pre></td></tr></table></figure></p><p><strong>获取meta属性content的值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta = soup.find(<span class="string">"meta"</span>)</span><br><span class="line">content = meta[<span class="string">"content"</span>]</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'meta_content'</span></span><br></pre></td></tr></table></figure></p><h2 id="lxml的使用"><a href="#lxml的使用" class="headerlink" title="lxml的使用"></a>lxml的使用</h2><p><strong>初始化页面</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"index.html"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    html = f.read()</span><br><span class="line">    </span><br><span class="line">selector = etree.HTML(text)    <span class="comment"># 初始化生成一个XPath解析对象</span></span><br></pre></td></tr></table></figure></p><p><strong>获取h2中的内容</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h2 = selector.xpath(<span class="string">"//h2"</span>)</span><br><span class="line">h2_text = h2[<span class="number">0</span>].text<span class="comment"># 获取div id=left的class属性值和内容</span></span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello everyone!'</span></span><br></pre></td></tr></table></figure></p><p><strong>获取div id=left的class属性值和内容</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div = selector.xpath(<span class="string">"//div[@id='left']"</span>)    <span class="comment"># 获取div id=left节点</span></span><br><span class="line">content = div[<span class="number">0</span>].get(<span class="string">"class"</span>)    <span class="comment"># 获取class属性值</span></span><br><span class="line">text = div[<span class="number">0</span>].text        <span class="comment"># 获取该节点的内容</span></span><br><span class="line">print(content, text)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'content'</span> <span class="string">'左边标题'</span></span><br></pre></td></tr></table></figure></p><p><strong>获取所有div</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">divs = selector.xpath(<span class="string">"//div"</span>)<span class="comment"># 获取div class=content的节点</span></span><br><span class="line">print(divs)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Element div at <span class="number">0x7f1368093648</span>&gt;,</span><br><span class="line"> &lt;Element div at <span class="number">0x7f136856d988</span>&gt;,</span><br><span class="line"> &lt;Element div at <span class="number">0x7f1363fe2708</span>&gt;]</span><br></pre></td></tr></table></figure></p><p><strong>获取div class=content的节点</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">divs = selector.xpath(<span class="string">"//div[@class='content']"</span>) <span class="comment"># 获取网站一的连接内容和链接</span></span><br><span class="line">print(divs)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;Element div at <span class="number">0x7f1368093648</span>&gt;, &lt;Element div at <span class="number">0x7f136856d988</span>&gt;]</span><br></pre></td></tr></table></figure></p><p><strong>获取网站一的连接内容和链接</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">par_a = selector.xpath(<span class="string">"//div[@id='right']"</span>)    <span class="comment"># 连接a节点的父节点</span></span><br><span class="line">a = par_a[<span class="number">0</span>].getchildren()[<span class="number">0</span>].text        <span class="comment"># 获取该父节点的第一个子节点的内容</span></span><br><span class="line">a_href = par_a[<span class="number">0</span>].getchildren()[<span class="number">0</span>].get(<span class="string">"href"</span>)    <span class="comment"># 获取链接</span></span><br><span class="line">print(a, a_href)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'www.example1.com'</span> <span class="string">'#link1'</span></span><br></pre></td></tr></table></figure></p><p><strong>获取meta的content属性值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta = selector.xpath(<span class="string">"//meta[@name='meta_name']"</span>)    <span class="comment"># 获取meta节点</span></span><br><span class="line">content = meta[<span class="number">0</span>].get(<span class="string">"content"</span>)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'meta_content'</span></span><br></pre></td></tr></table></figure></p><p><strong>获取所有网址的内容</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web = selector.xpath(<span class="string">"//a[@class='link']"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> web:</span><br><span class="line">    print(i.text)</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.example1.com</span><br><span class="line">www.example2.com</span><br></pre></td></tr></table></figure></p><p>以上遍历HTML内容大致信息也就如此，基本上满足一般的使用。更详细信息请参照<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/" target="_blank" rel="noopener">bs4官方文档</a> 以及 <a href="https://lxml.de/api/index.html" target="_blank" rel="noopener">lxml文档</a>。</p><h2 id="附加-CSS选择器"><a href="#附加-CSS选择器" class="headerlink" title="附加:CSS选择器"></a>附加:CSS选择器</h2><p>index.html文件内容不变，我们先加载html:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'index.html'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    html = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建response对象</span></span><br><span class="line">response = HtmlResponse(url=<span class="string">"http://www.example.com"</span>, body=html, encoding=<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="获取h2中的内容"><a href="#获取h2中的内容" class="headerlink" title="获取h2中的内容"></a>获取h2中的内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = response.css(<span class="string">'h2::text'</span>).extract_first()</span><br></pre></td></tr></table></figure><h3 id="获取div-id-left的class属性值和内容"><a href="#获取div-id-left的class属性值和内容" class="headerlink" title="获取div id=left的class属性值和内容"></a>获取div id=left的class属性值和内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">div = response.css(<span class="string">'div[id="left"]'</span>).extract_first()<span class="comment"># 获取该div元素</span></span><br><span class="line">class_ = div.attrib.get(<span class="string">'class'</span>)<span class="comment"># 获取属性class的值</span></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">class_ = response.css(<span class="string">'div[id="left"]::attr("class")'</span>).extract_first()</span><br><span class="line"><span class="comment"># 获取内容</span></span><br><span class="line">content = response.css(<span class="string">'div[id="left"]::text'</span>).extract_first()</span><br></pre></td></tr></table></figure><h3 id="获取所有div"><a href="#获取所有div" class="headerlink" title="获取所有div"></a>获取所有div</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">divs = response.css(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure><h3 id="获取div-class-content的节点"><a href="#获取div-class-content的节点" class="headerlink" title="获取div class=content的节点"></a>获取div class=content的节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">divs = response.css(<span class="string">'div[class=content]'</span>)</span><br></pre></td></tr></table></figure><h3 id="获取网站一的链接内容和链接"><a href="#获取网站一的链接内容和链接" class="headerlink" title="获取网站一的链接内容和链接"></a>获取网站一的链接内容和链接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站一的链接内容</span></span><br><span class="line">a_text = response.css(<span class="string">'div[id="right"]&gt;a:nth-child(1)::text'</span>).extract_first()</span><br><span class="line"><span class="comment"># 链接</span></span><br><span class="line">a = response.css(<span class="string">'div[id="right"]&gt;a:nth-child(1)'</span>)</span><br><span class="line">href = a.attrib.get(<span class="string">'href'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">href = response.css(<span class="string">'div[id="right"]&gt;a:nth-child(1)::attr("href")'</span>).extract_first()</span><br></pre></td></tr></table></figure><h3 id="获取meta的content属性值"><a href="#获取meta的content属性值" class="headerlink" title="获取meta的content属性值"></a>获取meta的content属性值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meta = response.css(<span class="string">'meta[name="meta_name"]'</span>)<span class="comment"># 获取meta元素</span></span><br><span class="line">content = meta.attrib.get(<span class="string">"content"</span>)<span class="comment"># 或值</span></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">content = response.css(<span class="string">'meta[name="meta_name"]::attr("content")'</span>).extract_first()</span><br></pre></td></tr></table></figure><h3 id="获取所有网址的内容"><a href="#获取所有网址的内容" class="headerlink" title="获取所有网址的内容"></a>获取所有网址的内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_texts = response.css(<span class="string">'div[id="right"]&gt;a::text'</span>).extract()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      当我们爬取一个网站时，获取到该网站的源码，要想从里面得到我们所需要的数据，就得对该源码进行梳理、提取我们所需的信息，该篇文章简单的介绍一下对HTML源码的遍历提取。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="HTML遍历" scheme="https://mistacker.github.io/tags/HTML%E9%81%8D%E5%8E%86/"/>
    
      <category term="lxml" scheme="https://mistacker.github.io/tags/lxml/"/>
    
      <category term="bs4" scheme="https://mistacker.github.io/tags/bs4/"/>
    
  </entry>
  
  <entry>
    <title>一个设计签名的小程序</title>
    <link href="https://mistacker.github.io/2018/10/16/design/"/>
    <id>https://mistacker.github.io/2018/10/16/design/</id>
    <published>2018-10-16T15:17:49.646Z</published>
    <updated>2018-10-16T15:17:49.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个制作设计签名的小程序，话不多说，效果图如下：</p></blockquote><h3 id="运行界面："><a href="#运行界面：" class="headerlink" title="运行界面："></a>运行界面：</h3><p><img src="/images/design.png" alt=""></p><h3 id="输入姓名："><a href="#输入姓名：" class="headerlink" title="输入姓名："></a>输入姓名：</h3><p><img src="/images/design2.png" alt=""></p><h3 id="一键设计："><a href="#一键设计：" class="headerlink" title="一键设计："></a>一键设计：</h3><p><img src="/images/design3.png" alt=""></p><p>下面是程序的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Tk, Label, Entry, Button, PhotoImage</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox <span class="keyword">as</span> tkMessageBox</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_img</span><span class="params">(url, row, column)</span>:</span></span><br><span class="line">    <span class="string">"""显示图片"""</span></span><br><span class="line">    image_bytes = requests.get(url).content</span><br><span class="line">    data_stream = io.BytesIO(image_bytes)</span><br><span class="line">    pil_image = Image.open(data_stream)</span><br><span class="line">    pi = ImageTk.PhotoImage(image=pil_image, width=<span class="number">500</span>, height=<span class="number">180</span>)</span><br><span class="line">    l2 = Label(image=pi)</span><br><span class="line">    l2.image = pi</span><br><span class="line">    l2.grid(row=row, column=column)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">design</span><span class="params">(url, data, text, row, column)</span>:</span></span><br><span class="line">    <span class="string">"""访问接口"""</span></span><br><span class="line">    data[<span class="string">"id"</span>] = text</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rs = requests.post(url, data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> rs.status_code == <span class="number">200</span>:</span><br><span class="line">        gif_src = rs.text.split(<span class="string">"="</span>)[<span class="number">1</span>].lstrip(<span class="string">"\""</span>).rstrip(<span class="string">"\"&gt;"</span>)</span><br><span class="line">        gif_all = urljoin(url, gif_src)</span><br><span class="line">        show_img(gif_all, row, column)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">button_thing</span><span class="params">(url, data, entry, label_row, label_column)</span>:</span></span><br><span class="line">    <span class="string">"""按钮事件"""</span></span><br><span class="line">    entry_text = entry.get()</span><br><span class="line">    <span class="keyword">if</span> entry_text == <span class="string">""</span>:</span><br><span class="line">        tkMessageBox.showinfo(<span class="string">"出错了"</span>, <span class="string">"姓名为空!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        design(url, data, entry_text, label_row, label_column)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTK</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title)</span>:</span></span><br><span class="line">        self.tk = <span class="keyword">None</span></span><br><span class="line">        self.title = title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self, add=None, mult=None, width=None, height=None, s_width=None, s_height=None, resizable=<span class="params">(False, False)</span>)</span>:</span></span><br><span class="line">        self.tk = Tk()</span><br><span class="line">        <span class="keyword">if</span> add:</span><br><span class="line">            <span class="keyword">assert</span> s_width <span class="keyword">or</span> s_height, <span class="string">"Add parameter error"</span></span><br><span class="line">            self.tk.geometry(<span class="string">"+&#123;&#125;+&#123;&#125;"</span>.format(s_width, s_height))</span><br><span class="line">        <span class="keyword">if</span> mult:</span><br><span class="line">            <span class="keyword">assert</span> height <span class="keyword">or</span> width, <span class="string">"Mult parameter error"</span></span><br><span class="line">            self.tk.geometry(<span class="string">"&#123;&#125;x&#123;&#125;"</span>.format(width, height))</span><br><span class="line">        self.tk.title(self.title)</span><br><span class="line">        self.tk.resizable(*resizable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_label</span><span class="params">(self, row, column, text=None, *args, **kwargs)</span>:</span></span><br><span class="line">        self.label = Label(self.tk, text=text, *args, **kwargs)</span><br><span class="line">        self.label.grid(row=row, column=column)</span><br><span class="line">        <span class="keyword">return</span> self.label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_entry</span><span class="params">(self, row, column, *args, **kwargs)</span>:</span></span><br><span class="line">        self.entry = Entry(self.tk, *args, **kwargs)</span><br><span class="line">        self.entry.grid(row=row, column=column)</span><br><span class="line">        <span class="keyword">return</span> self.entry</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_button</span><span class="params">(self, row, column, *args, **kwargs)</span>:</span></span><br><span class="line">        self.button = Button(self.tk, *args, **kwargs)</span><br><span class="line">        self.button.grid(row=row, column=column)</span><br><span class="line">        <span class="keyword">return</span> self.button</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> self.tk</span><br><span class="line">        self.tk.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">"http://www.jiqie.com/a/re22.php"</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"id1"</span>: <span class="string">"30"</span>,</span><br><span class="line">        <span class="string">"id2"</span>: <span class="string">"901"</span>,</span><br><span class="line">        <span class="string">"id3"</span>: <span class="string">"#0000FF"</span>,</span><br><span class="line">        <span class="string">"id4"</span>: <span class="string">"#0000DD"</span>,</span><br><span class="line">        <span class="string">"id5"</span>: <span class="string">"#0000AA"</span>,</span><br><span class="line">        <span class="string">"id6"</span>: <span class="string">"#000077"</span>,</span><br><span class="line">        <span class="string">"idi"</span>: <span class="string">"jiqie"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = MyTK(<span class="string">"个人签名"</span>)</span><br><span class="line">    t.init(add=<span class="keyword">True</span>, s_width=<span class="number">450</span>, s_height=<span class="number">250</span>)</span><br><span class="line">    t.add_label(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"姓名:"</span>)</span><br><span class="line">    entry = t.add_entry(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    label_row = <span class="number">0</span></span><br><span class="line">    label_column = <span class="number">10</span></span><br><span class="line">    t.add_button(<span class="number">2</span>, <span class="number">1</span>, text=<span class="string">"一件设计签名"</span>, command=<span class="keyword">lambda</span>: button_thing(url, data, entry, label_row, label_column))</span><br><span class="line">    <span class="comment"># t.add_button(2, 1, text="一件设计签名", command=lambda: Thread(target=button_thing, args=(url, data, entry, label_row, label_column)).start())</span></span><br><span class="line">    t.loop()</span><br></pre></td></tr></table></figure></p><p><em>简单的玩一玩，高手勿喷，有指点的可以留言或者发邮箱，谢谢。</em></p>]]></content>
    
    <summary type="html">
    
      现在都流行个性签名嘛，彰显个性，美观优雅，故此调用一下接口，通过GUI写了一个界面，组成了这一个小程序。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="tkinter" scheme="https://mistacker.github.io/tags/tkinter/"/>
    
  </entry>
  
  <entry>
    <title>OSROOM安装使用</title>
    <link href="https://mistacker.github.io/2018/10/15/osroom/"/>
    <id>https://mistacker.github.io/2018/10/15/osroom/</id>
    <published>2018-10-15T11:20:20.919Z</published>
    <updated>2018-10-15T11:20:20.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><code>OSROOM</code>支持<code>Linux</code>中部署，<code>windows</code>未测试通过</li><li>建议使用<code>Ubuntu&gt;=14.04</code>版本</li><li>测试通过操作系统有<code>Ubuntu 14.04, 16.04, 18.04</code>; <code>Centos 6.5</code>;</li><li>其他<code>Linux</code>系统还未测试</li></ul><h3 id="Python要求"><a href="#Python要求" class="headerlink" title="Python要求"></a>Python要求</h3><ul><li><code>Python 3.4</code>以上版本，比如<code>Python 3.4</code>, <code>Python 3.5</code>, <code>Python 3.6</code></li></ul><h2 id="Python依赖包安装"><a href="#Python依赖包安装" class="headerlink" title="Python依赖包安装"></a>Python依赖包安装</h2><h3 id="创建Python虚拟环境"><a href="#创建Python虚拟环境" class="headerlink" title="创建Python虚拟环境"></a>创建Python虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> virtualenv -p python3 env</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><ul><li><p>进入依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source env/bin/active</span><br></pre></td></tr></table></figure></li><li><p>进入osroom项目根目录</p></li><li>使用pip安装依赖包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>请看<a href="http://docs.mongoing.com/" target="_blank" rel="noopener">Mongodb文档</a>与<a href="http://www.redis.cn/documentation.html" target="_blank" rel="noopener">Redis文档</a></li></ul><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>因为<code>osroom</code>源代码只把配置文件<code>config.py</code>和数据库配置文件<code>db_config.py</code>的<code>sample</code>文件上传到<code>git</code>，所以请先复制修改名称。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入apps/configs</span></span><br><span class="line">cp config_sample.py config.py</span><br><span class="line">cp db_config_sample db_config.py</span><br></pre></td></tr></table></figure></p><p>编辑<code>db_config.py</code>，在配置中对应位置填写好数据库用户名和密码。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim db_config.py</span><br></pre></td></tr></table></figure></p><h2 id="初始化第一个用户"><a href="#初始化第一个用户" class="headerlink" title="初始化第一个用户"></a>初始化第一个用户</h2><ul><li>进入项目的<code>python</code>虚拟环境</li><li>进入根目录运行<code>start.py add_user</code>，操作如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> env/bin/action</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python start.py add_user</span></span><br><span class="line"> * [User] add</span><br><span class="line">Input username:root</span><br><span class="line">Input email:xiaopingwoo@163.com</span><br><span class="line">Input password(Password at least 8 characters):</span><br><span class="line">[Warning]: 密码至少8个字符！ 至少包含数字，字母，特殊字符中的任意两种</span><br><span class="line"></span><br><span class="line">Input password(Password at least 8 characters):</span><br><span class="line"> * Create root role...</span><br><span class="line">Create root user role successfully</span><br><span class="line"> * Create root user...</span><br><span class="line"> * Create a root user role successfully</span><br><span class="line"> * Create the average user role...</span><br><span class="line"> * Create a generic user role successfully</span><br><span class="line">The basic information is as follows</span><br><span class="line">Username: root</span><br><span class="line">Email: h*****irr@***.com</span><br><span class="line">User role: Root</span><br><span class="line">Password: #D****qw123</span><br><span class="line">End</span><br></pre></td></tr></table></figure></li></ul><h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><p>使用自带的服务测试是否能够成功运行<code>osroom</code>.</p><h3 id="启动OSROOM"><a href="#启动OSROOM" class="headerlink" title="启动OSROOM"></a>启动<code>OSROOM</code></h3><ul><li><p>进入<code>osroom</code>项目目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python start.py runserver --host 127.0.0.1 --port 5000</span></span><br></pre></td></tr></table></figure></li><li><p>打开浏览器访问 <a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a></p></li></ul><p>更多信息请前往<a href="https://osroom.github.io/osroom-doc/osr/v1.0/app/install/" target="_blank" rel="noopener">OSROOM DOC</a></p>]]></content>
    
    <summary type="html">
    
      最近研究了一下开源的OSROOM项目，顺便写一下OSROOM安装以及基本的实验运行；该项目写的非常好，值得学习。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
      <category term="flask" scheme="https://mistacker.github.io/categories/python/flask/"/>
    
    
      <category term="mongodb" scheme="https://mistacker.github.io/tags/mongodb/"/>
    
      <category term="redis" scheme="https://mistacker.github.io/tags/redis/"/>
    
      <category term="osroom" scheme="https://mistacker.github.io/tags/osroom/"/>
    
  </entry>
  
  <entry>
    <title>Flask中的信号</title>
    <link href="https://mistacker.github.io/2018/10/14/signal/"/>
    <id>https://mistacker.github.io/2018/10/14/signal/</id>
    <published>2018-10-14T14:02:44.075Z</published>
    <updated>2018-10-14T14:02:44.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong>0.6新版功能</strong></p><p>从<code>Flask 0.6</code>开始，<code>Flask</code>继承了信号支持。这个支持由<code>blinker</code>库提供的，并且当它不可用时会优雅地退回。</p><p>什么是信号？信号通过发送发生在和新框架的其他地方或<code>Flask</code>扩展的动作时通知来帮助你解耦应用。简而言之，信号允许特定的发送端通知订阅者发生了什么。</p><p><code>Flask</code>提供了几个信号，其他的扩展可能会提供更多。另外，请注意信号倾向于通知订阅者，而不应该鼓励订阅者修改数据。你会注意到，信号似乎和一些内置的装饰器做同样的事情。然后它们工作的方式是有差异的。譬如核心的<code>before_request()</code>处理程序以特定的顺序执行，并且可以在返回响应之前放弃请求。相比之下，所有信号的处理器执行的顺序没有定义，并且不修改任何数据、</p><p>信号之于其他处理器最大的优势是你可以在一秒钟的不同的时段上安全订阅。譬如这些临时的订阅对单元测试很有用。比如你想要知道哪个模板被作为请求的一部分渲染：信号允许你完全地了解这些。</p><h2 id="订阅信号"><a href="#订阅信号" class="headerlink" title="订阅信号"></a>订阅信号</h2><p>你可以使用信号的<code>connect()</code>方法来订阅信号。该函数第一个参数是信号发出时要调用的函数，第二个参数是可选的，用于确定信号的发送端。退订一个信号，可以使用<code>disconnect()</code>方法。</p><p>对于所有的核心<code>Flask</code>信号，发送端都是发出信号的应用。当你订阅一个信号，情趣噩耗也提供一个发送端，除非你确实详见听全部应用的信号。这在你开发一个扩展的时候尤其正确。</p><p>比如这里有一个用于在单元测试中找出哪个模板被渲染和传入模板的变量的助手上下文管理器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> template_rendered</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">captured_temolates</span><span class="params">(app)</span>:</span></span><br><span class="line">    recorded = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(sender, template, context, **extra)</span>:</span></span><br><span class="line">        recorded.append((template, context))</span><br><span class="line">    template_rendered.connect(record, app)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> recorded</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        template_rendered.disconnect(record, app)</span><br></pre></td></tr></table></figure></p><p>这可以很容易地与一个测试客户端配对：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> captured_templates(app) <span class="keyword">as</span> templates:</span><br><span class="line">    rv = app.test_client().get(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">assert</span> rv.status_code == <span class="number">200</span></span><br><span class="line">    <span class="keyword">assert</span> len(templates) == <span class="number">1</span></span><br><span class="line">    template, context = templates[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> template.name == <span class="string">'index.html'</span></span><br><span class="line">    <span class="keyword">assert</span> len(context[<span class="string">'items'</span>]) == <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>确保订阅使用了一个额外的<code>**extra</code>参数，这样当<code>Flask</code>对象引入新参数时你的调用不会失败。</p><p>代码中，从<code>with</code>块的应用<code>app</code>中流出的渲染的所有模板现在会被记录到<code>templates</code>变量。无论何时模板被渲染，模板对象和上下文中都会被添加到它里面。</p><p>此外，也有一个方便的助手方法(<code>connected_to()</code>)，它允许你临时地把函数订阅到信号并使用信号自己的上下文管理器。因为这个上下文管理器的返回值不能有我们决定，所以必须吧列表作为参数传入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> template_rendered</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">captured_templates</span><span class="params">(app, recorded, **extra)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(sender, template, context)</span>:</span></span><br><span class="line">        recorded.append((template, context))</span><br><span class="line">    <span class="keyword">return</span> template_rendered.connected_to(record, app)</span><br></pre></td></tr></table></figure></p><p>上面的例子会看起来是这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">templates = []</span><br><span class="line"><span class="keyword">with</span> captured_templates(app, ttemplates, **extra):</span><br><span class="line">    ...</span><br><span class="line">    template, context = templates[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p><em>注：<code>connected_to()</code>方法出现于<code>Blinker 1.1</code></em></p><h2 id="创建信号"><a href="#创建信号" class="headerlink" title="创建信号"></a>创建信号</h2><p>如果你想要在自己的应用中使用信号，你可以直接使用<code>blinker</code>库。最常见的用法是自定义的<code>Namespace</code>中命名信号。这也是大多数时候推荐的做法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> blinker <span class="keyword">import</span> Namespace</span><br><span class="line">my_signals = Namespace()</span><br></pre></td></tr></table></figure></p><p>现在你可以这样创建新的信号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model_saved = my_signals.signal(<span class="string">"model-saved"</span>)</span><br></pre></td></tr></table></figure></p><p>这里使用唯一的信号名，简化调试。可以用<code>name</code>属性来访问信号名。</p><h4 id="给扩展开发者"><a href="#给扩展开发者" class="headerlink" title="给扩展开发者"></a>给扩展开发者</h4><p>如果你在编写一个<code>Flask</code>扩展并且你想优雅地在没有<code>blinker</code>安装时退化，你可以用<code>flask.signals.Namespace</code>这么做。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>如果你想要发出信号，调用<code>send()</code>方法可以做到。它接受发送端作为第一个参数，和一些推送到信号订阅者的可选关键字参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        model_saved.send(self)</span><br></pre></td></tr></table></figure></p><p>永远尝试选择一个合适的发送端。如果你有一个发出信号的类，把<code>self</code>作为发送端。如果你从一个随机的函数发出信号，把<code>current_app._get_current_object()</code>作为发送端。<br>传递代理作为发送端</p><p>永远不要向信号传递<code>current_app</code>作为发送端，使用<code>current_app._get_current_object()</code>作为替代。这样的原因是，<code>current_app</code>是一个代理，而不是真正的应用对象。</p><h2 id="信号与Flask的请求上下文"><a href="#信号与Flask的请求上下文" class="headerlink" title="信号与Flask的请求上下文"></a>信号与Flask的请求上下文</h2><p>信号在接收时，完全支持请求上下文。上下文本地的变量在<code>request_started</code>和<code>request_finished</code>一贯可用，所以你可以新人<code>flask.g</code>和其他需要的东西。注意发送信号和<code>request_tearing_down</code>信号中描述的限制。</p><h2 id="基于装饰器的信号订阅"><a href="#基于装饰器的信号订阅" class="headerlink" title="基于装饰器的信号订阅"></a>基于装饰器的信号订阅</h2><p>你可以在<code>Blinker 1.1</code>中容易地用新的<code>connect_via()</code>装饰器订阅信号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> template_rendered</span><br><span class="line"></span><br><span class="line"><span class="meta">@template_rendered.connect_via(app)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">when_template_rendered</span><span class="params">(sender, template, context, **extra)</span>:</span></span><br><span class="line">    print(<span class="string">"Template %s is rendered with %s"</span> % (template.name, context))</span><br></pre></td></tr></table></figure></p><h2 id="核心信号"><a href="#核心信号" class="headerlink" title="核心信号"></a>核心信号</h2><p>下列是<code>Flask</code>中存在的信号：</p><h4 id="flask-template-rendered"><a href="#flask-template-rendered" class="headerlink" title="flask.template_rendered"></a>flask.template_rendered</h4><p>当模板成功渲染的时候，这个信号就会发出。这个信号与模板实例<code>template</code>和上下文的字典(名为<code>context</code>)一起调用。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_template_renders</span><span class="params">(sender, template, context, **extra)</span>:</span></span><br><span class="line">    sender.logger.debug(<span class="string">'Rendering template "%s" with context %s'</span>, template.name <span class="keyword">or</span> <span class="string">'string template'</span>, context)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> template_rendered</span><br><span class="line"></span><br><span class="line">template_rendered.connect(log_template_renders, app)</span><br></pre></td></tr></table></figure></p><h4 id="flask-request-started"><a href="#flask-request-started" class="headerlink" title="flask.request_started"></a>flask.request_started</h4><p>这个信号在此处建立请求上下文之外的任何请求处理开始前发送。因为请求上下文已经被约束，订阅者可以用<code>request</code>之类的标准全局代理访问请求。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_request</span><span class="params">(sender, **extra)</span>:</span></span><br><span class="line">    sender.logger.debug(<span class="string">'Request context is set up'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request_started</span><br><span class="line"></span><br><span class="line">request_started.connect(log_request, app)</span><br></pre></td></tr></table></figure></p><h4 id="flask-request-finished"><a href="#flask-request-finished" class="headerlink" title="flask.request_finished"></a>flask.request_finished</h4><p>这个信号恰好在请求发送给客户端之前发送。它传递名为<code>response</code>的响应。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_response</span><span class="params">(sender, response, **extra)</span>:</span></span><br><span class="line">    sender.logger.debug(<span class="string">'Request context is about to close down. Response: %s'</span>, response)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request_finished</span><br><span class="line">request_finished.connect(log_response, app)</span><br></pre></td></tr></table></figure></p><h4 id="flask-got-request-exception"><a href="#flask-got-request-exception" class="headerlink" title="flask.got_request_exception"></a>flask.got_request_exception</h4><p>这个信号在请求处理中抛出异常时发送。它在标准一场处理生效之前，甚至是在没有异常处理的情况下发送。异常本身会通过<code>exception</code>传递订阅函数。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exception</span><span class="params">(sender, exception, **extra)</span>:</span></span><br><span class="line">    sender.logger.debug(<span class="string">'Got exception during processing: %s'</span>, exception)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> got_request_exception</span><br><span class="line">got_request_exception.connect(log_exception, app)</span><br></pre></td></tr></table></figure></p><h4 id="flask-request-tearing-down"><a href="#flask-request-tearing-down" class="headerlink" title="flask.request_tearing_down"></a>flask.request_tearing_down</h4><p>这个信号在请求销毁时发送。他总是被调用，即使发生异常。当前监听这个信号的函数会在常规销毁处理后被调用，但这不是你可以依赖的。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_db_connection</span><span class="params">(sender, **extra)</span>:</span></span><br><span class="line">    session.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request_tearing_down</span><br><span class="line">request_tearing_down.connect(close_db_connection, app)</span><br></pre></td></tr></table></figure></p><p>从<code>Flask 0.9</code>，如果有异常的话他会被传递一个<code>exc</code>关键字餐朱引用导致销毁的异常。</p><h4 id="flask-appcontext-tearing-down"><a href="#flask-appcontext-tearing-down" class="headerlink" title="flask.appcontext_tearing_down"></a>flask.appcontext_tearing_down</h4><p>这个消息在应用上下文销毁时发送。它总是被调用，即使发生异常。当前建英这个信号的函数会在常规销毁处理后被调用，但这不是你可以依赖的。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_db_connection</span><span class="params">(sender, **extra)</span>:</span></span><br><span class="line">    session.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request_tearing_down</span><br><span class="line">appcontext_tearing_down.connect(close_db_connection, app)</span><br></pre></td></tr></table></figure></p><p>如果有一场他会被传递一个exc关键字参数引用导致销毁的异常。</p><h4 id="flask-appcontext-pushed"><a href="#flask-appcontext-pushed" class="headerlink" title="flask.appcontext_pushed"></a>flask.appcontext_pushed</h4><p>这个信号在应用上下文压入栈时发送。发送者是应用对象。这通常在单元测试中为了暂时地钩住信息比较有用。例如这个可以用来提前在g对象上设置一些资源。</p><p>用法示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">from</span> flask impo</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_set</span><span class="params">(app, user)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">        g.user = user</span><br><span class="line">    <span class="keyword">with</span> appcontext_pushed.connected_to(handler, app):</span><br><span class="line">        <span class="keyword">yield</span></span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def test_user_me(self):</span><br><span class="line">    with user_set(app, &apos;john&apos;):</span><br><span class="line">        c = app.test_client()</span><br><span class="line">        resp = c.get(&apos;/users/me&apos;)</span><br><span class="line">        assert resp.data == &apos;username=john&apos;</span><br></pre></td></tr></table></figure></p><p>0.10 新版功能</p><h4 id="flask-appcontext-popped"><a href="#flask-appcontext-popped" class="headerlink" title="flask.appcontext_popped"></a>flask.appcontext_popped</h4><p>这个信号在应用上下文弹出栈时发送。发送这是应用对象。这通常在<code>appcontext_tearing_down</code>信号发送后发送。</p><p>0.10 新版功能</p><h4 id="flask-message-flashed"><a href="#flask-message-flashed" class="headerlink" title="flask.message_flashed"></a>flask.message_flashed</h4><p>这个信号在应用对象闪现一个消息时发送。消息作为<code>message</code>命名参数发送，分别则是<code>categpry</code>参数。</p><p>订阅示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recorded = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(sender, message, category, **extra)</span>:</span></span><br><span class="line">    recorded.append((message, category))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> message_flashed</span><br><span class="line">message_flashed.connect(record, app)</span><br></pre></td></tr></table></figure></p><p>0.10 新版功能</p><p>文章借鉴<a href="https://docs.pythontab.com/flask/flask0.10/index.html" target="_blank" rel="noopener">Flask中文手册</a></p>]]></content>
    
    <summary type="html">
    
      从 Flask 0.6 开始， Flask 集成了信号支持。这个支持由 blinker 库提供， 并且当它不可用时会优雅地退回。什么是信号？信号通过发送发生在核心框架的其它地方或 Flask 扩展的动作时的通知来帮助你解耦应用。简而言之，信号允许特定的发送端通知订阅者发生了什么。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
      <category term="flask" scheme="https://mistacker.github.io/categories/python/flask/"/>
    
    
      <category term="信号" scheme="https://mistacker.github.io/tags/%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="blinker" scheme="https://mistacker.github.io/tags/blinker/"/>
    
  </entry>
  
  <entry>
    <title>电子邮件</title>
    <link href="https://mistacker.github.io/2018/10/13/email/"/>
    <id>https://mistacker.github.io/2018/10/13/email/</id>
    <published>2018-10-13T14:07:09.624Z</published>
    <updated>2018-10-13T14:07:09.624Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇主要实现了一个手动发送电子邮件的“代码客户端”。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib, sys</span><br><span class="line"></span><br><span class="line">message_template = <span class="string">"""To: &#123;&#125;</span></span><br><span class="line"><span class="string">From: &#123;&#125;</span></span><br><span class="line"><span class="string">Subject: Test Message from test.py</span></span><br><span class="line"><span class="string">Hello,</span></span><br><span class="line"><span class="string">This is a test message send to you from the test.py program in Foundations of python Network Programming.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">4</span>:</span><br><span class="line">        name = sys.argv[<span class="number">0</span>]</span><br><span class="line">        print(<span class="string">"Usage: &#123;&#125; server fromaddr toaddr [toaddr...]"</span>.format(name))</span><br><span class="line">        sys.exit(<span class="number">2</span>)</span><br><span class="line">    server, fromaddr, toaddr = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>:]</span><br><span class="line">    message = message_template.format((<span class="string">","</span>.join(toaddr)), fromaddr)</span><br><span class="line">    connection = smtplib.SMTP(server)</span><br><span class="line">    connection.sendmail(fromaddr, toaddr, message)</span><br><span class="line">    connection.quit()</span><br><span class="line">    </span><br><span class="line">    s = <span class="string">""</span> <span class="keyword">if</span> len(toaddr) == <span class="number">1</span> <span class="keyword">else</span> <span class="string">"s"</span></span><br><span class="line">    print(<span class="string">"Message send to &#123;&#125; recopint&#123;&#125;"</span>.format(len(toaddr), s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在命令行运行上面的文件，应该能够连接成功并发送：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3 test.py mail.example.com sender@example.com recipient@example.com</span></span><br><span class="line">Message send to 1 recipient</span><br></pre></td></tr></table></figure></p><p>本示例完全使用的是<code>python</code>内置函数，无第三方包。</p><p>&emsp;&emsp;当然，有时候使用上面代码运行时会报错。很大可能原因是由于很多大公司的电子邮件服务器需要我们提供账号密码进行登录验证来证明我们并非垃圾邮件发送者。这就涉及到了连接<code>SMTP</code>服务器需要认证，否则就不允许我们发送电子邮件。</p><p>&emsp;&emsp;对于认证本身是相当简单的。<code>smtplib</code>提供了一个<code>login()</code>函数，该函数以用户名和密码作为参数进行合法的<code>SMTP</code>验证，这样就保证了合法的身份，如示例二。</p><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib, sys</span><br><span class="line"><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line">message_template = <span class="string">"""To: &#123;&#125;</span></span><br><span class="line"><span class="string">From: &#123;&#125;</span></span><br><span class="line"><span class="string">Subject: Test Message from test.py</span></span><br><span class="line"><span class="string">Hello,</span></span><br><span class="line"><span class="string">This is a test message send to you from the test.py program in Foundations of python Network Programming.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">4</span>:</span><br><span class="line">        name = sys.argv[<span class="number">0</span>]</span><br><span class="line">        print(<span class="string">"Usage: &#123;&#125; server fromaddr toaddr [toaddr...]"</span>.format(name))</span><br><span class="line">        sys.exit(<span class="number">2</span>)</span><br><span class="line">    server, fromaddr, toaddr = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>:]</span><br><span class="line">    message = message_template.format((<span class="string">","</span>.join(toaddr)), fromaddr)</span><br><span class="line"></span><br><span class="line">    username = input(<span class="string">"Enter username: "</span>)</span><br><span class="line">    password = getpass(<span class="string">"Enter password: "</span>)</span><br><span class="line"></span><br><span class="line">    connection = smtplib.SMTP(server)</span><br><span class="line">    connection.login(username, password)</span><br><span class="line"></span><br><span class="line">    connection.sendmail(fromaddr, toaddr, message)</span><br><span class="line"></span><br><span class="line">    s = <span class="string">""</span> <span class="keyword">if</span> len(toaddr) == <span class="number">1</span> <span class="keyword">else</span> <span class="string">"s"</span></span><br><span class="line">    print(<span class="string">"Message send to &#123;&#125; recopint&#123;&#125;"</span>.format(len(toaddr), s))</span><br><span class="line">    connection.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示例二所示，<code>SMTP</code>的用户验证问题得以解决，但是在运行方面难免会有各种各样的问题发生，代码不够健壮性。为了增强代码的健壮性，以及各方面的“突发”问题，对代码进行了重构，形成示例三的最终代码。</p><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib, socket, sys</span><br><span class="line"><span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line">message_template = <span class="string">"""To: &#123;&#125;</span></span><br><span class="line"><span class="string">From: &#123;&#125;</span></span><br><span class="line"><span class="string">Subject: Test Message from test.py</span></span><br><span class="line"><span class="string">Hello,</span></span><br><span class="line"><span class="string">This is a test message send to you from the test.py program in Foundations of python Network Programming.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">4</span>:</span><br><span class="line">        name = sys.argv[<span class="number">0</span>]</span><br><span class="line">        print(<span class="string">"Usage: &#123;&#125; server fromaddr toaddr [toaddr...]"</span>.format(name))</span><br><span class="line">        sys.exit(<span class="number">2</span>)</span><br><span class="line">    server, fromaddr, toaddr = sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>:]</span><br><span class="line">    message = message_template.format((<span class="string">","</span>.join(toaddr)), fromaddr)</span><br><span class="line"></span><br><span class="line">    username = input(<span class="string">"Enter username: "</span>)</span><br><span class="line">    password = getpass(<span class="string">"Enter password: "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        connection = smtplib.SMTP(server)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            connection.login(username, password)</span><br><span class="line">        <span class="keyword">except</span> smtplib.SMTPException <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"Authentication failed:"</span>, e)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        connection.sendmail(fromaddr, toaddr, message)</span><br><span class="line">    <span class="keyword">except</span> (socket.gaierror, socket.error, socket.herror, smtplib.SMTPException) <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Your message may not have been sent!"</span>)</span><br><span class="line">        print(e)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s = <span class="string">""</span> <span class="keyword">if</span> len(toaddr) == <span class="number">1</span> <span class="keyword">else</span> <span class="string">"s"</span></span><br><span class="line">        print(<span class="string">"Message send to &#123;&#125; recopint&#123;&#125;"</span>.format(len(toaddr), s))</span><br><span class="line">        connection.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要说明一点的是，在验证<code>SMTP</code>时，如：新浪邮箱等，需要输入账号密码进行验证。而有的则不用输入密码，如：QQ邮箱，密码只需要输入授权码即可。具体操作可根据异常信息自行判断。</p>]]></content>
    
    <summary type="html">
    
      实现一个可发送的电子邮件客户端。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="email" scheme="https://mistacker.github.io/tags/email/"/>
    
  </entry>
  
  <entry>
    <title>一些练习题</title>
    <link href="https://mistacker.github.io/2018/10/13/problem/"/>
    <id>https://mistacker.github.io/2018/10/13/problem/</id>
    <published>2018-10-13T14:07:09.624Z</published>
    <updated>2018-10-13T14:07:09.624Z</updated>
    
    <content type="html"><![CDATA[<p>找了一些题目，想用Python解决一下。</p><h2 id="反向迭代一个序列"><a href="#反向迭代一个序列" class="headerlink" title="反向迭代一个序列"></a>反向迭代一个序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是一个list，最快的方法使用reverse</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempList.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不是list，需要手动重排</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">&gt;&gt;&gt;print(temp[i])</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="查询替换文本中的字符串"><a href="#查询替换文本中的字符串" class="headerlink" title="查询替换文本中的字符串"></a>查询替换文本中的字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单的方法使用replace()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempstr = <span class="string">"hello you hello python are you ok"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempstr = tempstr.replace(<span class="string">"you"</span>, <span class="string">"python"</span>) <span class="comment"># 把所有的you替换成python</span></span><br><span class="line"><span class="string">'hello python hello python are python ok'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用正则</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempstr = <span class="string">"hello you hello python are you ok"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = <span class="string">r'(hello|Use)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.sub(rex, <span class="string">"Bye"</span>, tempstr))<span class="comment"># 把所有hello替换成Bye</span></span><br><span class="line"><span class="string">'Bye you Bye python are you ok'</span></span><br></pre></td></tr></table></figure><h2 id="python实现单例模式"><a href="#python实现单例模式" class="headerlink" title="python实现单例模式"></a>python实现单例模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：可以使用__new__方法。</span></span><br><span class="line"><span class="comment"># 在__new__方法中把类实例绑定到类变量_instance上，如果cls._instance为None表示该类没有实例化过，实例化该类并返回。反之直接返回。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">        cls._instance = object.__new__(cls, *args, *kwargs)</span><br><span class="line">    <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(SingleTon)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1.a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(test1), id(test2))</span><br><span class="line"><span class="number">140666831839864</span> <span class="number">140666831839864</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用装饰器，建立过实例就放到instances里面，下次建立的时候先检查此里面是否有实例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">SingleTon</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        instances = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">        instances[cls] = cls(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> instances[cls]</span><br><span class="line">        <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@SingleTon</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LastClass</span><span class="params">(object)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = LastClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = LastClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(test1), id(test2))</span><br><span class="line"><span class="number">140666831841376</span> <span class="number">140666831841376</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：共享属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SignalTon</span><span class="params">(object)</span>:</span></span><br><span class="line">        _state = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    obj = object.__new__(cls, *args, **kwargs)</span><br><span class="line">    obj.__dict__ = cls._state</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(SignalTon)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1.a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="重新实现str-strip"><a href="#重新实现str-strip" class="headerlink" title="重新实现str.strip()"></a>重新实现str.strip()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">rightStrip</span><span class="params">(tempStr, splitStr)</span>:</span></span><br><span class="line">        endindex = tempStr.rfind(splitStr)</span><br><span class="line">        <span class="keyword">while</span> endindex != <span class="number">-1</span> <span class="keyword">and</span> endindex == len(tempStr)<span class="number">-1</span>:</span><br><span class="line">    tempStr = tempStr[:endindex]</span><br><span class="line">    endindex = tempStr.rfind(splitStr)</span><br><span class="line">        <span class="keyword">return</span> tempStr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">leftStrip</span><span class="params">(tempStr, splitStr)</span>:</span></span><br><span class="line">        startindex = tempStr.find(splitStr)</span><br><span class="line">        <span class="keyword">while</span> startindex == <span class="number">0</span>:</span><br><span class="line">    tempStr = tempStr[startindex+<span class="number">1</span>:]</span><br><span class="line">    startindex = tempStr.find(splitStr)</span><br><span class="line">        <span class="keyword">return</span> tempStr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">" H "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str)</span><br><span class="line"> H </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(leftStrip(str, <span class="string">" "</span>))</span><br><span class="line">H </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rightStrip(str, <span class="string">" "</span>))</span><br><span class="line"> H</span><br></pre></td></tr></table></figure><h2 id="给列表中字典排序"><a href="#给列表中字典排序" class="headerlink" title="给列表中字典排序"></a>给列表中字典排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist = [&#123;<span class="string">"name"</span>: <span class="string">"a"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"b"</span>, <span class="string">"age"</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"c"</span>, <span class="string">"age"</span>: <span class="number">25</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist.sort(key=<span class="keyword">lambda</span> x:x.get(<span class="string">"age"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(alist)</span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'a'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'c'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'b'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="打乱一个排序好的列表"><a href="#打乱一个排序好的列表" class="headerlink" title="打乱一个排序好的列表"></a>打乱一个排序好的列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist = range(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = list(alist)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v)</span><br><span class="line">[<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="获取最大公约数"><a href="#获取最大公约数" class="headerlink" title="获取最大公约数"></a>获取最大公约数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">max_common</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="keyword">while</span> b:</span><br><span class="line">    a, b = b, a%b</span><br><span class="line"><span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h2 id="获取两个数的最小公倍数"><a href="#获取两个数的最小公倍数" class="headerlink" title="获取两个数的最小公倍数"></a>获取两个数的最小公倍数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">25</span></span><br><span class="line">b = <span class="number">15</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_common</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = a * b</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">a, b = b, a%b</span><br><span class="line">    <span class="keyword">return</span> c//a</span><br></pre></td></tr></table></figure><h2 id="实现一个简单的栈结构"><a href="#实现一个简单的栈结构" class="headerlink" title="实现一个简单的栈结构"></a>实现一个简单的栈结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.value = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">self.value.append(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">s = self.value.pop()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">st = Stack()</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">print(stack.value)</span><br><span class="line">stack.pop()</span><br><span class="line">print(stack.value)</span><br></pre></td></tr></table></figure><h2 id="合并两个列表，排除重复元素"><a href="#合并两个列表，排除重复元素" class="headerlink" title="合并两个列表，排除重复元素"></a>合并两个列表，排除重复元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">merge_list</span><span class="params">(*args)</span>:</span></span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">    s = s.union(i)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>merge_list(a, b)</span><br><span class="line">&#123;<span class="string">'d'</span>, <span class="string">'y'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'x'</span>, <span class="string">'f'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      搜罗了一些常见的知识点题，总结了一下，用python一一进行实现。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="习题" scheme="https://mistacker.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>nginx的使用</title>
    <link href="https://mistacker.github.io/2018/10/13/nginx/"/>
    <id>https://mistacker.github.io/2018/10/13/nginx/</id>
    <published>2018-10-13T14:07:09.620Z</published>
    <updated>2018-10-13T14:07:09.620Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx?"></a>什么是Nginx?</h4><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡；支持高并发，并且消耗资源非常低，运行非常稳定。</p><p>由于nginx的优点，促使它快速成为使用广泛的http服务器，这里主要介绍一下nginx的使用及配置(ubuntu下)。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><p>nginx安装完后，默认时启动的，可以通过：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep nginx</span><br></pre></td></tr></table></figure></p><p>来查看nginx是否启动。如果是下面这种情况即是启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root       881  0.0  0.0 140620  1512 ?        Ss   20:12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data   882  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   883  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   884  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   885  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">mistack+  5146  0.0  0.0  21536  1088 pts/0    S+   20:53   0:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure></p><p>如果没有启动，可通过下面命令来启动，已启动可重启、或停止：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx start    <span class="comment"># 启动</span></span><br><span class="line">sudo /etc/init.d/nginx restart    <span class="comment"># 重启</span></span><br><span class="line">sudo /etc/init.d/nginx stop    <span class="comment"># 停止</span></span><br></pre></td></tr></table></figure></p><p>打开浏览器，访问localhost，可以看到如下内容：<br><img src="/images/nginx.png" alt=""><br>即nginx安装并启动成功。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx默认配置文件在 <code>/etc/nginx/conf.d/default.conf</code>。我们可以删除默认配置文件在该文件夹下新建一个 <code>nginx.conf</code> 的配置文件。由于nginx支持的功能很多，我们逐一配置，皆存放在<code>nginx.conf</code>中。每次更改了配置信息，需要重新启动nginx服务器才能生效。</p><h3 id="静态http服务器"><a href="#静态http服务器" class="headerlink" title="静态http服务器"></a>静态http服务器</h3><blockquote><p>ngin可以将服务器上的静态文件，通过http协议展现给客户端浏览器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;    <span class="comment"># 监听端口</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;    <span class="comment"># 静态文件路径，也是默认路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><blockquote><p>nginx可以实现反向代理，客户端可以访问nginx，然后由nginx去访问web服务器，把服务器返回的数据再返回给客户端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;    <span class="comment"># 监听端口</span></span><br><span class="line">    location / &#123;</span><br><span class="line">proxy_pass http://192.168.0.100:8000;  <span class="comment"># 应用服务器HTTP地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><blockquote><p>当一个网站有很多访问量时，一台服务器往往会压力过大，容易崩溃；为了解决这个问题，nginx提供了负载均衡—-即配置多个相同的服务器分担压力，一旦其中一个挂掉，页不会影响用户的访问。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream app &#123;</span><br><span class="line">    server    192.168.0.100:8000;    <span class="comment"># 服务器1</span></span><br><span class="line">    server    192.168.0.200:8000;    <span class="comment"># 服务器2</span></span><br><span class="line">    server    192.168.0.250:8000;    <span class="comment"># 服务器3</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><blockquote><p>有的网站，访问量不多，而要节约成本，需要将多个网站部署到同一台服务器上。这种技术叫做虚拟主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    www.aaa.com;    <span class="comment"># www.aaa.com域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    www.bbb.com;    <span class="comment"># www.bbb.com域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8001;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h3><blockquote><p>nginx本身不支持动态网页，但是它可以通过uwsgi来将请求扔给某些语言或框架处理(例如：PHP/Python/Perl等)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream  app &#123;</span><br><span class="line">    server localhost:5000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    127.0.0.1;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_read_timeout    3600;</span><br><span class="line">        uwsgi_pass    app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>更多配置信息请见 <a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">Nginx中文文档</a></p>]]></content>
    
    <summary type="html">
    
      nginx作为web服务器时下还是非常流行的，主要介绍下nginx的常用配置。如需更多配置设置，请详阅官方文档。
    
    </summary>
    
      <category term="linux" scheme="https://mistacker.github.io/categories/linux/"/>
    
    
      <category term="nginx" scheme="https://mistacker.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Celery的介绍</title>
    <link href="https://mistacker.github.io/2018/10/13/celery/"/>
    <id>https://mistacker.github.io/2018/10/13/celery/</id>
    <published>2018-10-13T14:07:09.620Z</published>
    <updated>2018-10-13T14:07:09.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Celery"><a href="#什么是Celery" class="headerlink" title="什么是Celery?"></a>什么是Celery?</h2><p>&emsp;&emsp;<code>Celery</code>是一个简单、灵活可靠、能处理大量消息的分布式系统。它是一个专注于实时处理的任务队列，并且也支持任务调度。<code>Celery</code>有广泛的用户与贡献者社区，而且是开源的，使用 <code>BSD许可证</code> 授权。<br>何为任务队列</p><p>&emsp;&emsp;任务队列是一种在线程或机器间分发任务的机制。</p><p>&emsp;&emsp;消息队列的输入是工作的一个单元，成为任务，独立的职程(worker)进程持续监视队列中是否有需要处理的新任务。</p><p>&emsp;&emsp;<code>Celery</code>用消息通信，通常使用中间人(broker)在客户端和职程间斡旋。这个过程从客户端向队列现价消息开始，之后中间人把消息派送给职程。</p><p>&emsp;&emsp;<code>Celery</code>系统可包含多个职程和中间人，以此获得高可用和横向扩展能力。</p><p>&emsp;&emsp;<code>Celery</code>是用<code>Python</code>编写的，但协议可以用任何语言实现。迄今，已有<code>Ruby</code>实现的<code>RCelery</code>、<code>node.js</code>实现的<code>node-celery</code>以及一个<code>PHP</code>客户端，语言互通也可以通过<code>using webhooks</code>实现。</p><p><code>celery</code>工作流程图如下：<br><img src="/images/celery.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以从<code>Python Package Index(PyPI)</code>或源码安装<code>Celery</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U Celery</span><br><span class="line">或</span><br><span class="line">$ easy_install -U Celery</span><br></pre></td></tr></table></figure></p><p>源码安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvfz celery-0.0.0.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> celery-0.0.0</span><br><span class="line">$ python setup.py build</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></p><p><em>注：如果不是在virtualenv里安装，最后一条命令必须以管理员权限执行。</em></p><h2 id="Celery的优点"><a href="#Celery的优点" class="headerlink" title="Celery的优点"></a>Celery的优点</h2><ol><li><p>简单<br> Celery易于使用和维护，并且它不需要配置文件。下面是一个你可以实现的最简应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'hello'</span>, broker=<span class="string">'amgp://guest@localhost//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></li><li><p>高可用性<br> 倘若连接丢失或失败，职程和客户端自动重试，并且一些中间人通过主/主 或 主/从 方式复制来提高可用性。</p></li><li><p>快速<br> 单个Celery进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级。</p></li><li><p>灵活<br> Celery几乎所有部分都可以扩展或单独使用。可以自制连接池、序列化、压缩模式、日志、调度器、消费者、生产者、自动扩展、中间人传输或更多。<br>Celery支持</p></li><li><p>中间人</p></li></ol><ul><li>RabbitMQ, Redis</li><li>MongoDB(实验性), ZwroMQ(实验性)</li><li>CouchDB(实验性), SQLAlchemy(实验性)</li><li>Django ORM(实验性), Amazon SQS(实验性)</li><li>还有更多…</li></ul><ol start="2"><li>并发</li></ol><ul><li>prefork(多进程)</li><li>Eventlet, gevent</li><li>多线程/单线程</li></ul><ol start="3"><li>结果存储</li></ol><ul><li>AMQP, Redis</li><li>memcached, MongoDB</li><li>SQLAlchemy, Django ORM</li><li>Apache Cassandra</li></ul><ol start="4"><li>序列化</li></ol><ul><li>pickle, json, yaml, msgpack</li><li>zlib, bzip2压缩</li><li>密码学消息签名</li></ul><h2 id="框架继承"><a href="#框架继承" class="headerlink" title="框架继承"></a>框架继承</h2><p>Celery通常与Web框架继承，其中的一些甚至已经有了集成包：</p><table><thead><tr><th>框架</th><th>名称</th></tr></thead><tbody><tr><td>Django</td><td>django-celery</td></tr><tr><td>Pyramid</td><td>pyramid_celery</td></tr><tr><td>Pylons</td><td>celery-pylons</td></tr><tr><td>Flask</td><td>不需要</td></tr><tr><td>web2py</td><td>web2py-celery</td></tr><tr><td>Tornado</td><td>tornado-celery</td></tr></tbody></table><p>继承包并非是严格必要的，但他们让开发更简便。</p><h2 id="中间人-非实验性"><a href="#中间人-非实验性" class="headerlink" title="中间人(非实验性)"></a>中间人(非实验性)</h2><h3 id="使用-RabbitMQ"><a href="#使用-RabbitMQ" class="headerlink" title="使用 RabbitMQ"></a>使用 RabbitMQ</h3><ol><li><p>安装与配置<br><code>RabbitMQ</code>是默认的中间人，所以除了需要你要使用的中间人实例的 <code>URL</code> 位置，它并不需要任何额外的依赖或起始配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'amqp://gueest:guest@localhost:5672//'</span></span><br></pre></td></tr></table></figure><p> <code>Celery</code> 中间人 <code>URL</code> 的描述和完整的中间人可用配置选项列表见 <a href="http://docs.jinkan.org/docs/celery/configuration.html#conf-broker-settings" target="_blank" rel="noopener">Broker Settings</a> </p></li><li><p>安装 <code>RabbitMQ</code> 服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rabbitmq-server</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>RabbitMQ</code><br>要使用 <code>Celery</code>，我们需要创建一个 <code>RabbitMQ</code> 用户、一个虚拟主机，并且允许这个用户访问这个虚拟主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user myuser mypassword</span><br><span class="line">sudo rabbitmqctl add_vhost myvhost</span><br><span class="line">sudo rabbitmqctl set_permissions -p myvhost myuser <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-Redis"><a href="#使用-Redis" class="headerlink" title="使用 Redis"></a>使用 Redis</h3><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install redis-server</span><br><span class="line">或</span><br><span class="line">pip install -U celery[redis]</span><br></pre></td></tr></table></figure></li><li><p>配置<br>配置非常简单，只需要设置 <code>Redis</code> 数据库的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'redis://localhost:6379/0'</span></span><br></pre></td></tr></table></figure><p>URL 的各式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis://:password@hostname:port/db_number</span><br></pre></td></tr></table></figure></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>首先你需要一个<code>Celery</code>实例，成为<code>Celery</code>应用或直接简称应用。既然这个实例用于你想在<code>Celery</code>中做的一切事——比如创建任务、管理职程的入口点，它必须可以被其他模块导入。</p><p>在此教程中，你的一切都容纳在单一模块里，对于更大的项目，你会想创建独立模块。</p><p>创建<code>tasks.py</code>，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'amqp://guest@localhost//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p><code>Celery</code>的第一个参数是当前模块的名称，这个参数必须有。第二个参数是中间人关键字参数，指定你所使用的消息中间人的<code>URL</code>，此处使用了<code>RabbitMQ</code>你可以写<code>amqp://localhost</code>，而对于<code>Redis</code>你可以写<code>redis://localhost</code></p><p>你定义了一个单一<code>add</code>任务，返回两个数的和。</p><h2 id="运行Celery职程服务器"><a href="#运行Celery职程服务器" class="headerlink" title="运行Celery职程服务器"></a>运行<code>Celery</code>职程服务器</h2><p>你现在可以用<code>worker</code>参数执行我们的程序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker --loglevel=info</span><br></pre></td></tr></table></figure></p><h2 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h2><p>你可以用<code>delay()</code>方法来调用任务。</p><p>这是<code>apply_async()</code>方法的快捷方式，该方法允许你更好地控制任务执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from tasks import add</span><br><span class="line">&gt;&gt;&gt; add.delay(4, 4)</span><br></pre></td></tr></table></figure></p><h2 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h2><p>如果你想要保持追踪任务的状态，<code>Celery</code>需要在某个地方存储或者发送这些状态。可以从内建的几个结果后端选择：<code>SQLAlchemy/Django ORM</code>、<code>Memcached</code>、<code>Redis</code>、<code>AMQP(RabbitMQ)</code>或<code>MongoDB</code>，或者你可以自制。如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Celery(<span class="string">'tasks'</span>, backed=<span class="string">'amqp'</span>, broker=<span class="string">'amqp://'</span>)</span><br></pre></td></tr></table></figure></p><p>或者如果你想要把<code>Redis</code>用作结果后端，但仍然用<code>RabbitMQ</code>作为消息中间人：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Celery(<span class="string">'tasks'</span>, backend=<span class="string">'redis://localhost'</span>, broker=<span class="string">'amqp://'</span>)</span><br></pre></td></tr></table></figure></p><p>调用任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p><code>read()</code>方法查看任务是否完成处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>更多信息请参照 <a href="http://docs.jinkan.org/docs/celery/" target="_blank" rel="noopener">Celery文档</a></p>]]></content>
    
    <summary type="html">
    
      Celery是一个简单、灵活可靠、能处理大量消息的分布式系统。它是一个专注于实时处理的任务队列，并且也支持任务调度。Celery有广泛的用户与贡献者社区，而且是开源的，使用 BSD许可证 授权。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="celery" scheme="https://mistacker.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API的设计策略</title>
    <link href="https://mistacker.github.io/2018/10/13/restful_api/"/>
    <id>https://mistacker.github.io/2018/10/13/restful_api/</id>
    <published>2018-10-13T14:07:09.620Z</published>
    <updated>2018-10-13T14:07:09.620Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>RESTful API</code>是目前较成熟的一套互联网应用程序<code>API</code>设计理论；这里主要介绍下如何通过<code>RESTful API</code>设计出一套合理好用的<code>API</code>接口。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><code>API</code>与用户的通信协议，总是要使用<code>HTTPs</code>协议。<br><em>注：如果想要了解<code>HTTPs</code>协议的设计思想和运行过程，可访问<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制</a></em></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>应该尽量将<code>API</code>部署在专用域名之下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/</span><br></pre></td></tr></table></figure></p><p>如果确定<code>API</code>很简单，不会有进一步扩展，可以考虑放在主域名下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://exampl.org/api/</span><br></pre></td></tr></table></figure></p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>应该将<code>API</code>的版本号放入<code>URL</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure></p><p>另一种做法是，将版本号放在<code>HTTP</code>头信息中，但不如放入<code>URL</code>方便和直观。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径又称”终点(<code>endpoint</code>)”，表示<code>API</code>的具体网址。</p><p>在<code>RESTful</code>架构中，每一个网址代表一种资源，而资源的名称往往与数据库的表明对应。一般来说，数据库中的表都是同种记录的”集合”，所以<code>API</code>中的资源名称也该使用复数。</p><p>如下面这个<code>API</code>提供动物园的信息，包括各种动物和雇员。路径设计如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure></p><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a><code>HTTP</code>动词</h2><p><code>HTTP</code>动词是指对资源的集体操作方式的类型。</p><p>常用的<code>HTTP</code>动词有以下五个：</p><table><thead><tr><th>动词名称</th><th>SQL命令</th><th>含义 </th></tr></thead><tbody><tr><td>GET</td><td>SELECT</td><td>从服务其取出资源(一项或多项)</td></tr><tr><td>POST</td><td>CREATE</td><td>在服务器新建一个资源</td></tr><tr><td>PUT</td><td>UPDATE</td><td>在服务器更新资源(客户端提供改变后的完整资源)</td></tr><tr><td>PATCH</td><td>UPDATE</td><td>在服务器更新资源(客户端提供改变的属性)</td></tr><tr><td>DELETE</td><td>DELETE</td><td>从服务器删除资源</td></tr></tbody></table><p>还有两个不常用的<code>HTTP</code>动词：</p><table><thead><tr><th>动词名称</th><th>含义</th></tr></thead><tbody><tr><td>HEAD</td><td>获取资源的元数据</td></tr><tr><td>OPTIONS</td><td>获取信息，关于资源的哪些属性是客户端可以更改的</td></tr></tbody></table><p>例如：</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息(提供次动物园全部信息)</li><li>PATCH /zoos/ID：更新某个指定动物园的信息(提供次动物园的部分信息)</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h2 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h2><p>如果记录数量很多，服务器不可能都将他们返回给客户端。<code>API</code>应该提供参数，过滤返回结果。</p><p>下面是一下常见的参数：</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序</li><li>?animal_type_id=1：指定筛选条件</li></ul><p>参数的设计允许存在冗余，即允许<code>API</code>路径和<code>URL</code>参数偶尔有重复指向同一资源。比如：<code>GET /zoos/ID/animals</code>与<code>GET /animals?zoos_id=ID</code>的含义相同。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>服务器向用户返回的状态码和提示信息，常见的如下面所示：</p><table><thead><tr><th>状态码</th><th>HTTP动词</th><th>含义</th></tr></thead><tbody><tr><td>200 OK</td><td>GET</td><td>服务器成功返回用户请求的数据，该操作是幂等的。</td></tr><tr><td>201 CREATED</td><td>POST/PUT/PATCH</td><td>用户新建或修改数据成功</td></tr><tr><td>202 Accepted</td><td>*</td><td>表示一个请求已经进入后台排队(异步任务)</td></tr><tr><td>204 NO CONTENT</td><td>DELETE</td><td>用户删除数据成功</td></tr><tr><td>400 INVA:ID REQUEST</td><td>POST/PUT/PATCH</td><td>用户发出的请求有错误，服务器没有进行新建或者修改数据的操作，该操作是幂等的</td></tr><tr><td>401 Unauthorized</td><td>*</td><td>表示用户没有权限(令牌、用户名、密码错误)</td></tr><tr><td>403 Forbidden</td><td>*</td><td>表示用户得到授权，但访问是被禁止的</td></tr><tr><td>404 NOT FOUND</td><td>*</td><td>用户发出的请求对应是不存在的记录，服务器没有进行操作，该操作是幂等的</td></tr><tr><td>406 Not Acceptable</td><td>GET</td><td>用户请求的格式不可得</td></tr><tr><td>410 Gone</td><td>GET</td><td>用户请求的资源被永久删除，且不会在得到</td></tr><tr><td>422 Unprocesable entity</td><td>POST/PUT/PATCH</td><td>当创建一个对象时，发生一个验证错误</td></tr><tr><td>500 INTERNAL SERVER ERROR</td><td>*</td><td>服务器发生错误，用户将无法判断发出的请求是否成功</td></tr></tbody></table><p>状态码完整列表在<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果状态码是<code>4xx</code>，就应该向用户返回出错信息。一般来说，返回的信息中将<code>error</code>作为键名，出错信息作为键值即可:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回结果</p><p>针对不同操作，服务器向用户反蝴蝶结果应该符合一下规范：</p><ul><li>GET /collection：返回资源对象列表(数组)</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><p><code>RESTful API</code>最好做到<code>Hypermedia</code>，即返回结果中提供链接，连向其他<code>API</code>方法，使得用户不查文档也知道下一步应该做什么。</p><p>比如，当用户像<code>api.example.com</code>的根目录发出请求，会得到这样一个文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “link”: &#123;</span><br><span class="line">        <span class="string">"rel"</span>: <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码表示，文档有一个<code>link</code>属性，用户读这个属性就知道下一步该调用什么<code>API</code>了。<code>rel</code>表示这个<code>API</code>与当前网址的关系，<code>href</code>表示<code>API</code>的路径，<code>title</code>表示<code>API</code>的标题，<code>type</code>表示返回类型。</p><p><code>Hypermedia API</code>的设计被称为<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a>。<code>Github</code>的<code>API</code>就是这种设计，访问<code>api.github.com</code>会得到一个所有可用<code>API</code>的网址列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “current_user_url”： <span class="string">"https://api.github.com/user"</span>，</span><br><span class="line">    “current_user_authorizations_html_url”： <span class="string">"https://github.com/setti…applications&#123;/client_id&#125;"</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<code>api.github.com/user</code>，然后就得到下面结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"message"</span>:  <span class="string">"Requires authentication"</span>,</span><br><span class="line">    <span class="string">"documentation_url"</span>:    <span class="string">"https://developer.github.com/v3/users/#get-the-authenticated-user"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>API的身份认证应该使用OAuth 2.0框架.</li><li>服务器返回的数据格式，应该尽量使用JSON，避免使用XML.</li></ol><p>参考资料：<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">restful api设计</a></p>]]></content>
    
    <summary type="html">
    
      RESTful API是目前较成熟的一套互联网应用程序API设计理论；这里主要介绍下如何通过RESTful API设计出一套合理好用的API接口。
    
    </summary>
    
      <category term="URL" scheme="https://mistacker.github.io/categories/URL/"/>
    
    
      <category term="RESTful-api" scheme="https://mistacker.github.io/tags/RESTful-api/"/>
    
  </entry>
  
  <entry>
    <title>测试test文件</title>
    <link href="https://mistacker.github.io/2018/10/13/test/"/>
    <id>https://mistacker.github.io/2018/10/13/test/</id>
    <published>2018-10-13T14:07:09.620Z</published>
    <updated>2018-10-13T14:07:09.620Z</updated>
    
    <content type="html"><![CDATA[<p>这是测试内容</p><blockquote><p>先看看这个是否有效果显示<br>该文章是开启评论的</p></blockquote><p>这是运行的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python3</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这是该测试页面的描述，随便写的东西，只是为了让页面显示，看其作用。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python的多线程</title>
    <link href="https://mistacker.github.io/2018/10/13/thread/"/>
    <id>https://mistacker.github.io/2018/10/13/thread/</id>
    <published>2018-10-13T14:07:09.620Z</published>
    <updated>2018-10-13T14:07:09.620Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要执行同时执行多任务时，一般情况下我们会考虑多线程。</p><p><code>Python</code>标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，而<code>threading</code>是对<code>_thread</code>的封装。绝大多数下我们都会使用<code>threading</code>模块。</p><p>下面是一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(n ,int)</span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    print(<span class="string">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">'thread %s --&gt; %s'</span> % (threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s end.'</span> % threading.current_thread().name)</span><br><span class="line">        </span><br><span class="line">print(<span class="string">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=text, args=(<span class="number">5</span>,), name=<span class="string">'ChildThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s end.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread <span class="keyword">is</span> running</span><br><span class="line">thread ChildThread <span class="keyword">is</span> running</span><br><span class="line">thread ChildThread --&gt; 0</span><br><span class="line">thread ChildThread --&gt; 1</span><br><span class="line">thread ChildThread --&gt; 2</span><br><span class="line">thread ChildThread --&gt; 3</span><br><span class="line">thread ChildThread --&gt; 4</span><br><span class="line">thread ChildThread end.</span><br><span class="line">thread MainThread end.</span><br></pre></td></tr></table></figure></p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>对于多线程来说，往往有个弊端：所有变量都是由所有线程共享的，所以任何一个变量都可以被任何一个线程修改，如果同一时间修改同一变量，结果就会混乱。如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bank_money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_money</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> bank_money</span><br><span class="line">    bank_money = bank_money + count</span><br><span class="line">    bank_money = bank_money - count</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_num</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        change_money(count)</span><br><span class="line">        </span><br><span class="line">t1 = threading.Thread(target=do_num, args(<span class="number">100</span>,))</span><br><span class="line">t2 = threading.Thread(target=do_num, args(<span class="number">84</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(bank_money)</span><br></pre></td></tr></table></figure></p><p>这个例子不是很恰当，但是它能很好的表达出多线程的这种弊端：当<code>t1</code>和<code>t2</code>两个线程交替执行是，只要循环次数足够多，最终<code>bank_money</code>的结果不一定是<code>0</code>了。</p><p>为了解决这个问题我们要给<code>change_money()</code>加锁：当某个线程开始执行<code>change_money()</code>时，该线程即获得了锁，其他线程只能等待该线程执行完后，释放锁之后才能执行<code>change_money()</code>函数，这样就不会造成冲突。实例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bank_money = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_num</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 获取锁</span></span><br><span class="line">        locak.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change_money(count)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># 异常处理</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放锁</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure></p><p><code>do_num()</code>函数进行了以上更改，其他代码不变，这样执行最终结果扔会是<code>0</code>。需要注意的是，锁一定要释放，否则程序会进行不下去。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><code>Python</code>的线程虽然是真正的线程，但解释器执行代码时，有一个<code>GIL</code>锁：<code>Global Interpreter Lock</code>，任何<code>Python</code>线程执行前，必须先获得<code>GIL</code>锁，然后，每执行100条字节码，解释器就自动释放<code>GIL</code>锁，让别的线程有机会执行。这个<code>GIL</code>全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在<code>Python</code>中只能交替执行，即使100个线程跑在100核<code>CPU</code>上，也只能用到1个核。</p><p><code>GIL</code>是<code>Python</code>解释器设计的历史遗留问题，通常我们用的解释器是官方实现的<code>CPython</code>，要真正利用多核，除非重写一个不带<code>GIL</code>的解释器。</p><p>所以，在<code>Python</code>中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过<code>C</code>扩展来实现，不过这样就失去了<code>Python</code>简单易用的特点。</p><p>不过，也不用过于担心，<code>Python</code>虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个<code>Python</code>进程有各自独立的<code>GIL</code>锁，互不影响。</p><p>参考资料 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192823818768cd506abbc94eb5916192364506fa5d000#0" target="_blank" rel="noopener">多线程-廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      多线程往往是程序中较长使用的内容。python的多线程往往多需要怎么使用呢？这里主要介绍下python中多线程的使用方法及注意事项。仅供参考。
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="多线程" scheme="https://mistacker.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>WSGI的介绍</title>
    <link href="https://mistacker.github.io/2018/10/13/wsgi/"/>
    <id>https://mistacker.github.io/2018/10/13/wsgi/</id>
    <published>2018-10-13T14:07:09.620Z</published>
    <updated>2018-10-13T14:07:09.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>&emsp;&emsp; 在早期的<code>HTTP</code>编程中，许多<code>Python</code>服务都是被编写为简单的<code>CGI</code>脚本。每次收到请求就会出发<code>CGI</code>脚本。服务器对<code>HTTP</code>请求进行分割，将相应的参数以环境变量的形式传入<code>CGI</code>脚本中。<code>Python</code>程序员可以直接将这些输入参数和<code>HTTP</code>响应打印到标准输出，也可以借助标准库的<code>cgi</code>模块来查看。<br>&emsp;&emsp;在上面的方式会为每个接收到<code>HTTP</code>请求启动一个新的进程。这大大影响了服务器的性能，因此各种语言开始着手实现自己的<code>HTTP</code>服务器。<code>Python</code>在标准库中加入了<code>http.server</code>模块。使用该模块来实现服务时，程序员需要编写自己的子类继承<code>BaseHTTPRequestHandler</code>，并添加<code>do_GET()</code>和<code>do_POST()</code>方法。<br>&emsp;&emsp;其一些程序员想在支持返回动态页面的<code>Web</code>服务器上同事支持返回静态内容，因此出现了<code>mod_python</code>。<code>mod_python</code>是一个<code>Apache</code>模块，允许成功注册的<code>Python</code>函数提供自定义的<code>Apache</code>处理函数，并且在自定义处理函数中提供认证和日志功能以及返回内容。<code>mod_python</code>的<code>API</code>是<code>Apache</code>独有的。使用<code>Python</code>编写的处理函数接受一个特殊的<code>Apache request</code>对象。在处理函数内部，可以调用<code>apache</code>模块的特殊函数来与<code>Web</code>服务器进行交互。使用<code>mod_python</code>的应用程序与使用<code>CGI</code>或<code>http.server</code>编写的程序几乎毫无相似之处。<br>&emsp;&emsp;因此，在<code>Python</code>中使用上述不同方式编写<code>HTTP</code>应用程序，在设计与<code>Web</code>服务器交互的接口时都采用了某种特定的机制。使用<code>CGI</code>方式编写的服务至少需要重写一部分代码才能应用<code>http.server</code>。无论是使用<code>CGI</code>还是<code>http.server</code>编写的服务器程序，都需要经过修改才能够在<code>Apache</code>下运行。这使得<code>Python</code>网络服务的可移植性很差。<br>&emsp;&emsp;为了解决这一问题，<code>Python</code>社区在<code>PEP 333</code>中提出了<code>Web</code>服务器网管接口(<code>WSGI, Web Server Gateway Interface</code>)。而<code>WSGI</code>标准就是添加了一层中间层。通过这一中间层，用<code>Python</code>编写的<code>HTTP</code>服务就能够与任何<code>Web</code>服务器进行交互了。<code>WSGI</code>标准指定了一个调用惯例，如果所有主流的<code>Web</code>服务器的实现都遵循这一惯例，那么就能够直接在服务器中应用底层服务以及功能完整的<code>Web</code>框架，而无需修改原来的代码。各大<code>Web</code>服务器很快就遵循<code>WSGI</code>进行了实现。现在，<code>WSGI</code>已经成为了使用<code>Python</code>进行<code>HTTP</code>操作的标准方法。</p><h2 id="一个简单的HTTP服务"><a href="#一个简单的HTTP服务" class="headerlink" title="一个简单的HTTP服务"></a>一个简单的HTTP服务</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># A simple HTTP service built directly against the low-level WSGU spec.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pformat</span><br><span class="line"><span class="keyword">from</span> simple.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain; charset=utf-8"</span>&#125;</span><br><span class="line">    start_response(<span class="string">"200 OK"</span>, list(headers.items()))</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"Here is the WSGI environment:\r\n\r\n"</span>.encode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">yield</span> pformat(environ).encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    httpd = make_server(<span class="string">""</span>, <span class="number">8000</span>, app)</span><br><span class="line">    host, port = httpd.socket.getsockname()</span><br><span class="line">    print(<span class="string">"Serving on"</span>, host, <span class="string">"port"</span>, port)</span><br><span class="line">    httpd.server_forever()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据标准的定义，<code>WSGI</code>应用程序是可以被调用的，并且有两个输入参数。上面代码则是一个展示例子，其中使用一个简单的<code>Python</code>函数来表示可调用的<code>WSGI</code>应用程序。第一个参数是<code>environ</code>，用于接受一个字典，字典中提供的键值对是旧式的<code>CGI</code>环境变量集合的扩展。第二个参数本身是可以被调用的，习惯上会将其命名为<code>start_response()</code>，<code>WSGI</code>应用程序通过<code>start_response()</code>来声明响应头信息。被调用后，<code>app</code>函数可以开始生成字节字符串，也可以返回一个可迭代对象。该对象可以在迭代过程中生成字符串。<br>&emsp;&emsp;只看代码的话，你可能会觉得WSGI很简单，这是因为上面的代码只选择了一种简单的处理方式，没有展示出<code>WSGI</code>标准的完整说明而已。实际编写服务器程序时，复杂度就大大提升了。如果想了解相关细节的话，可以阅读<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP 3333</a>提出的现代<code>Python3</code>版本的<code>WSGI</code>。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>&emsp;&emsp;<code>WSGI</code>出现后，<code>WSGI</code>中间件的思想开始广为流传。未来<code>Python</code>服务可能应该被设计为一系列<code>WSGI</code>包装的函数。其中，有的包装函数会提供认证功能；有的会负责捕捉异常，记录日志；而有的则负责对指向仍然在机构中运行的老旧的<code>CMS</code>的<code>URL</code>进行反向代理，使用<code>Diazo</code>将这些<code>URL</code>重构，使之指向项目中最新页面。<br>&emsp;&emsp;尽管仍然有一些开发者会编写并使用<code>WSGI</code>中间件，但是现在大多数<code>Python</code>程序员使用<code>WSGI</code>的主要原因是它提供应用程序或框架与监听<code>HTTP</code>请求的<code>Web</code>服务器之间的可插拔性。</p>]]></content>
    
    <summary type="html">
    
      什么是WSGI？WSGI有什么意义？为什么会出现WSGI？与Python又有什么养的关系？不要急，这些问题的答案都在阅读全文中...
    
    </summary>
    
      <category term="python" scheme="https://mistacker.github.io/categories/python/"/>
    
    
      <category term="WSGI" scheme="https://mistacker.github.io/tags/WSGI/"/>
    
  </entry>
  
</feed>
