<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mistacker|博客</title>
  
  <subtitle>孤帆远影碧空尽，唯见长江天际流。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-06T09:24:42.677Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mistacker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WSGI的介绍</title>
    <link href="http://yoursite.com/2018/10/06/wsgi/"/>
    <id>http://yoursite.com/2018/10/06/wsgi/</id>
    <published>2018-10-06T09:24:42.721Z</published>
    <updated>2018-10-06T09:24:42.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>&emsp;&emsp; 在早期的<code>HTTP</code>编程中，许多<code>Python</code>服务都是被编写为简单的<code>CGI</code>脚本。每次收到请求就会出发<code>CGI</code>脚本。服务器对<code>HTTP</code>请求进行分割，将相应的参数以环境变量的形式传入<code>CGI</code>脚本中。<code>Python</code>程序员可以直接将这些输入参数和<code>HTTP</code>响应打印到标准输出，也可以借助标准库的<code>cgi</code>模块来查看。<br>&emsp;&emsp;在上面的方式会为每个接收到<code>HTTP</code>请求启动一个新的进程。这大大影响了服务器的性能，因此各种语言开始着手实现自己的<code>HTTP</code>服务器。<code>Python</code>在标准库中加入了<code>http.server</code>模块。使用该模块来实现服务时，程序员需要编写自己的子类继承<code>BaseHTTPRequestHandler</code>，并添加<code>do_GET()</code>和<code>do_POST()</code>方法。<br>&emsp;&emsp;其一些程序员想在支持返回动态页面的<code>Web</code>服务器上同事支持返回静态内容，因此出现了<code>mod_python</code>。<code>mod_python</code>是一个<code>Apache</code>模块，允许成功注册的<code>Python</code>函数提供自定义的<code>Apache</code>处理函数，并且在自定义处理函数中提供认证和日志功能以及返回内容。<code>mod_python</code>的<code>API</code>是<code>Apache</code>独有的。使用<code>Python</code>编写的处理函数接受一个特殊的<code>Apache request</code>对象。在处理函数内部，可以调用<code>apache</code>模块的特殊函数来与<code>Web</code>服务器进行交互。使用<code>mod_python</code>的应用程序与使用<code>CGI</code>或<code>http.server</code>编写的程序几乎毫无相似之处。<br>&emsp;&emsp;因此，在<code>Python</code>中使用上述不同方式编写<code>HTTP</code>应用程序，在设计与<code>Web</code>服务器交互的接口时都采用了某种特定的机制。使用<code>CGI</code>方式编写的服务至少需要重写一部分代码才能应用<code>http.server</code>。无论是使用<code>CGI</code>还是<code>http.server</code>编写的服务器程序，都需要经过修改才能够在<code>Apache</code>下运行。这使得<code>Python</code>网络服务的可移植性很差。<br>&emsp;&emsp;为了解决这一问题，<code>Python</code>社区在<code>PEP 333</code>中提出了<code>Web</code>服务器网管接口(<code>WSGI, Web Server Gateway Interface</code>)。而<code>WSGI</code>标准就是添加了一层中间层。通过这一中间层，用<code>Python</code>编写的<code>HTTP</code>服务就能够与任何<code>Web</code>服务器进行交互了。<code>WSGI</code>标准指定了一个调用惯例，如果所有主流的<code>Web</code>服务器的实现都遵循这一惯例，那么就能够直接在服务器中应用底层服务以及功能完整的<code>Web</code>框架，而无需修改原来的代码。各大<code>Web</code>服务器很快就遵循<code>WSGI</code>进行了实现。现在，<code>WSGI</code>已经成为了使用<code>Python</code>进行<code>HTTP</code>操作的标准方法。</p><h2 id="一个简单的HTTP服务"><a href="#一个简单的HTTP服务" class="headerlink" title="一个简单的HTTP服务"></a>一个简单的HTTP服务</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># A simple HTTP service built directly against the low-level WSGU spec.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pformat</span><br><span class="line"><span class="keyword">from</span> simple.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain; charset=utf-8"</span>&#125;</span><br><span class="line">    start_response(<span class="string">"200 OK"</span>, list(headers.items()))</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"Here is the WSGI environment:\r\n\r\n"</span>.encode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">yield</span> pformat(environ).encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    httpd = make_server(<span class="string">""</span>, <span class="number">8000</span>, app)</span><br><span class="line">    host, port = httpd.socket.getsockname()</span><br><span class="line">    print(<span class="string">"Serving on"</span>, host, <span class="string">"port"</span>, port)</span><br><span class="line">    httpd.server_forever()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据标准的定义，<code>WSGI</code>应用程序是可以被调用的，并且有两个输入参数。上面代码则是一个展示例子，其中使用一个简单的<code>Python</code>函数来表示可调用的<code>WSGI</code>应用程序。第一个参数是<code>environ</code>，用于接受一个字典，字典中提供的键值对是旧式的<code>CGI</code>环境变量集合的扩展。第二个参数本身是可以被调用的，习惯上会将其命名为<code>start_response()</code>，<code>WSGI</code>应用程序通过<code>start_response()</code>来声明响应头信息。被调用后，<code>app</code>函数可以开始生成字节字符串，也可以返回一个可迭代对象。该对象可以在迭代过程中生成字符串。<br>&emsp;&emsp;只看代码的话，你可能会觉得WSGI很简单，这是因为上面的代码只选择了一种简单的处理方式，没有展示出<code>WSGI</code>标准的完整说明而已。实际编写服务器程序时，复杂度就大大提升了。如果想了解相关细节的话，可以阅读<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP 3333</a>提出的现代<code>Python3</code>版本的<code>WSGI</code>。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>&emsp;&emsp;<code>WSGI</code>出现后，<code>WSGI</code>中间件的思想开始广为流传。未来<code>Python</code>服务可能应该被设计为一系列<code>WSGI</code>包装的函数。其中，有的包装函数会提供认证功能；有的会负责捕捉异常，记录日志；而有的则负责对指向仍然在机构中运行的老旧的<code>CMS</code>的<code>URL</code>进行反向代理，使用<code>Diazo</code>将这些<code>URL</code>重构，使之指向项目中最新页面。<br>&emsp;&emsp;尽管仍然有一些开发者会编写并使用<code>WSGI</code>中间件，但是现在大多数<code>Python</code>程序员使用<code>WSGI</code>的主要原因是它提供应用程序或框架与监听<code>HTTP</code>请求的<code>Web</code>服务器之间的可插拔性。</p>]]></content>
    
    <summary type="html">
    
      什么是WSGI？WSGI有什么意义？为什么会出现WSGI？与Python又有什么养的关系？不要急，这些问题的答案都在阅读全文中...
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://yoursite.com/tags/WSGI/"/>
    
  </entry>
  
  <entry>
    <title>一些练习题</title>
    <link href="http://yoursite.com/2018/10/06/problem/"/>
    <id>http://yoursite.com/2018/10/06/problem/</id>
    <published>2018-10-06T07:59:15.212Z</published>
    <updated>2018-10-06T07:59:15.184Z</updated>
    
    <content type="html"><![CDATA[<p>找了一些题目，想用Python解决一下。</p><h2 id="反向迭代一个序列"><a href="#反向迭代一个序列" class="headerlink" title="反向迭代一个序列"></a>反向迭代一个序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是一个list，最快的方法使用reverse</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempList.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不是list，需要手动重排</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">&gt;&gt;&gt;print(temp[i])</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="查询替换文本中的字符串"><a href="#查询替换文本中的字符串" class="headerlink" title="查询替换文本中的字符串"></a>查询替换文本中的字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单的方法使用replace()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempstr = <span class="string">"hello you hello python are you ok"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempstr = tempstr.replace(<span class="string">"you"</span>, <span class="string">"python"</span>) <span class="comment"># 把所有的you替换成python</span></span><br><span class="line"><span class="string">'hello python hello python are python ok'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用正则</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tempstr = <span class="string">"hello you hello python are you ok"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rex = <span class="string">r'(hello|Use)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.sub(rex, <span class="string">"Bye"</span>, tempstr))<span class="comment"># 把所有hello替换成Bye</span></span><br><span class="line"><span class="string">'Bye you Bye python are you ok'</span></span><br></pre></td></tr></table></figure><h2 id="python实现单例模式"><a href="#python实现单例模式" class="headerlink" title="python实现单例模式"></a>python实现单例模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：可以使用__new__方法。</span></span><br><span class="line"><span class="comment"># 在__new__方法中把类实例绑定到类变量_instance上，如果cls._instance为None表示该类没有实例化过，实例化该类并返回。反之直接返回。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">        cls._instance = object.__new__(cls, *args, *kwargs)</span><br><span class="line">    <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(SingleTon)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1.a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(test1), id(test2))</span><br><span class="line"><span class="number">140666831839864</span> <span class="number">140666831839864</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：使用装饰器，建立过实例就放到instances里面，下次建立的时候先检查此里面是否有实例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">SingleTon</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        instances = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">        instances[cls] = cls(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> instances[cls]</span><br><span class="line">        <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@SingleTon</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LastClass</span><span class="params">(object)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = LastClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = LastClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(test1), id(test2))</span><br><span class="line"><span class="number">140666831841376</span> <span class="number">140666831841376</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：共享属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SignalTon</span><span class="params">(object)</span>:</span></span><br><span class="line">        _state = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    obj = object.__new__(cls, *args, **kwargs)</span><br><span class="line">    obj.__dict__ = cls._state</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(SignalTon)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = TestClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1.a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test1.a, test2.a)</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="重新实现str-strip"><a href="#重新实现str-strip" class="headerlink" title="重新实现str.strip()"></a>重新实现str.strip()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">rightStrip</span><span class="params">(tempStr, splitStr)</span>:</span></span><br><span class="line">        endindex = tempStr.rfind(splitStr)</span><br><span class="line">        <span class="keyword">while</span> endindex != <span class="number">-1</span> <span class="keyword">and</span> endindex == len(tempStr)<span class="number">-1</span>:</span><br><span class="line">    tempStr = tempStr[:endindex]</span><br><span class="line">    endindex = tempStr.rfind(splitStr)</span><br><span class="line">        <span class="keyword">return</span> tempStr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">leftStrip</span><span class="params">(tempStr, splitStr)</span>:</span></span><br><span class="line">        startindex = tempStr.find(splitStr)</span><br><span class="line">        <span class="keyword">while</span> startindex == <span class="number">0</span>:</span><br><span class="line">    tempStr = tempStr[startindex+<span class="number">1</span>:]</span><br><span class="line">    startindex = tempStr.find(splitStr)</span><br><span class="line">        <span class="keyword">return</span> tempStr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">" H "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str)</span><br><span class="line"> H </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(leftStrip(str, <span class="string">" "</span>))</span><br><span class="line">H </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rightStrip(str, <span class="string">" "</span>))</span><br><span class="line"> H</span><br></pre></td></tr></table></figure><h2 id="给列表中字典排序"><a href="#给列表中字典排序" class="headerlink" title="给列表中字典排序"></a>给列表中字典排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist = [&#123;<span class="string">"name"</span>: <span class="string">"a"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"b"</span>, <span class="string">"age"</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"c"</span>, <span class="string">"age"</span>: <span class="number">25</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist.sort(key=<span class="keyword">lambda</span> x:x.get(<span class="string">"age"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(alist)</span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'a'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'c'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'b'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="打乱一个排序好的列表"><a href="#打乱一个排序好的列表" class="headerlink" title="打乱一个排序好的列表"></a>打乱一个排序好的列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist = range(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = list(alist)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(v)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v)</span><br><span class="line">[<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="获取最大公约数"><a href="#获取最大公约数" class="headerlink" title="获取最大公约数"></a>获取最大公约数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">max_common</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="keyword">while</span> b:</span><br><span class="line">    a, b = b, a%b</span><br><span class="line"><span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h2 id="获取两个数的最小公倍数"><a href="#获取两个数的最小公倍数" class="headerlink" title="获取两个数的最小公倍数"></a>获取两个数的最小公倍数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">25</span></span><br><span class="line">b = <span class="number">15</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_common</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = a * b</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">a, b = b, a%b</span><br><span class="line">    <span class="keyword">return</span> c//a</span><br></pre></td></tr></table></figure><h2 id="实现一个简单的栈结构"><a href="#实现一个简单的栈结构" class="headerlink" title="实现一个简单的栈结构"></a>实现一个简单的栈结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.value = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">self.value.append(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">s = self.value.pop()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">st = Stack()</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">print(stack.value)</span><br><span class="line">stack.pop()</span><br><span class="line">print(stack.value)</span><br></pre></td></tr></table></figure><h2 id="合并两个列表，排除重复元素"><a href="#合并两个列表，排除重复元素" class="headerlink" title="合并两个列表，排除重复元素"></a>合并两个列表，排除重复元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">merge_list</span><span class="params">(*args)</span>:</span></span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">    s = s.union(i)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>merge_list(a, b)</span><br><span class="line">&#123;<span class="string">'d'</span>, <span class="string">'y'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'x'</span>, <span class="string">'f'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      搜罗了一些常见的知识点题，总结了一下，用python一一进行实现。
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="习题" scheme="http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API的设计策略</title>
    <link href="http://yoursite.com/2018/10/01/restful_api/"/>
    <id>http://yoursite.com/2018/10/01/restful_api/</id>
    <published>2018-10-01T14:00:05.480Z</published>
    <updated>2018-10-01T14:00:05.436Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>RESTful API</code>是目前较成熟的一套互联网应用程序<code>API</code>设计理论；这里主要介绍下如何通过<code>RESTful API</code>设计出一套合理好用的<code>API</code>接口。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><code>API</code>与用户的通信协议，总是要使用<code>HTTPs</code>协议。<br><em>注：如果想要了解<code>HTTPs</code>协议的设计思想和运行过程，可访问<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制</a></em></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>应该尽量将<code>API</code>部署在专用域名之下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/</span><br></pre></td></tr></table></figure></p><p>如果确定<code>API</code>很简单，不会有进一步扩展，可以考虑放在主域名下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://exampl.org/api/</span><br></pre></td></tr></table></figure></p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>应该将<code>API</code>的版本号放入<code>URL</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure></p><p>另一种做法是，将版本号放在<code>HTTP</code>头信息中，但不如放入<code>URL</code>方便和直观。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径又称”终点(<code>endpoint</code>)”，表示<code>API</code>的具体网址。</p><p>在<code>RESTful</code>架构中，每一个网址代表一种资源，而资源的名称往往与数据库的表明对应。一般来说，数据库中的表都是同种记录的”集合”，所以<code>API</code>中的资源名称也该使用复数。</p><p>如下面这个<code>API</code>提供动物园的信息，包括各种动物和雇员。路径设计如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure></p><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a><code>HTTP</code>动词</h2><p><code>HTTP</code>动词是指对资源的集体操作方式的类型。</p><p>常用的<code>HTTP</code>动词有以下五个：</p><table><thead><tr><th>动词名称</th><th>SQL命令</th><th>含义 </th></tr></thead><tbody><tr><td>GET</td><td>SELECT</td><td>从服务其取出资源(一项或多项)</td></tr><tr><td>POST</td><td>CREATE</td><td>在服务器新建一个资源</td></tr><tr><td>PUT</td><td>UPDATE</td><td>在服务器更新资源(客户端提供改变后的完整资源)</td></tr><tr><td>PATCH</td><td>UPDATE</td><td>在服务器更新资源(客户端提供改变的属性)</td></tr><tr><td>DELETE</td><td>DELETE</td><td>从服务器删除资源</td></tr></tbody></table><p>还有两个不常用的<code>HTTP</code>动词：</p><table><thead><tr><th>动词名称</th><th>含义</th></tr></thead><tbody><tr><td>HEAD</td><td>获取资源的元数据</td></tr><tr><td>OPTIONS</td><td>获取信息，关于资源的哪些属性是客户端可以更改的</td></tr></tbody></table><p>例如：</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息(提供次动物园全部信息)</li><li>PATCH /zoos/ID：更新某个指定动物园的信息(提供次动物园的部分信息)</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h2 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h2><p>如果记录数量很多，服务器不可能都将他们返回给客户端。<code>API</code>应该提供参数，过滤返回结果。</p><p>下面是一下常见的参数：</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序</li><li>?animal_type_id=1：指定筛选条件</li></ul><p>参数的设计允许存在冗余，即允许<code>API</code>路径和<code>URL</code>参数偶尔有重复指向同一资源。比如：<code>GET /zoos/ID/animals</code>与<code>GET /animals?zoos_id=ID</code>的含义相同。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>服务器向用户返回的状态码和提示信息，常见的如下面所示：</p><table><thead><tr><th>状态码</th><th>HTTP动词</th><th>含义</th></tr></thead><tbody><tr><td>200 OK</td><td>GET</td><td>服务器成功返回用户请求的数据，该操作是幂等的。</td></tr><tr><td>201 CREATED</td><td>POST/PUT/PATCH</td><td>用户新建或修改数据成功</td></tr><tr><td>202 Accepted</td><td>*</td><td>表示一个请求已经进入后台排队(异步任务)</td></tr><tr><td>204 NO CONTENT</td><td>DELETE</td><td>用户删除数据成功</td></tr><tr><td>400 INVA:ID REQUEST</td><td>POST/PUT/PATCH</td><td>用户发出的请求有错误，服务器没有进行新建或者修改数据的操作，该操作是幂等的</td></tr><tr><td>401 Unauthorized</td><td>*</td><td>表示用户没有权限(令牌、用户名、密码错误)</td></tr><tr><td>403 Forbidden</td><td>*</td><td>表示用户得到授权，但访问是被禁止的</td></tr><tr><td>404 NOT FOUND</td><td>*</td><td>用户发出的请求对应是不存在的记录，服务器没有进行操作，该操作是幂等的</td></tr><tr><td>406 Not Acceptable</td><td>GET</td><td>用户请求的格式不可得</td></tr><tr><td>410 Gone</td><td>GET</td><td>用户请求的资源被永久删除，且不会在得到</td></tr><tr><td>422 Unprocesable entity</td><td>POST/PUT/PATCH</td><td>当创建一个对象时，发生一个验证错误</td></tr><tr><td>500 INTERNAL SERVER ERROR</td><td>*</td><td>服务器发生错误，用户将无法判断发出的请求是否成功</td></tr></tbody></table><p>状态码完整列表在<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果状态码是<code>4xx</code>，就应该向用户返回出错信息。一般来说，返回的信息中将<code>error</code>作为键名，出错信息作为键值即可:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回结果</p><p>针对不同操作，服务器向用户反蝴蝶结果应该符合一下规范：</p><ul><li>GET /collection：返回资源对象列表(数组)</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><p><code>RESTful API</code>最好做到<code>Hypermedia</code>，即返回结果中提供链接，连向其他<code>API</code>方法，使得用户不查文档也知道下一步应该做什么。</p><p>比如，当用户像<code>api.example.com</code>的根目录发出请求，会得到这样一个文档：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “link”: &#123;</span><br><span class="line">        <span class="string">"rel"</span>: <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">        <span class="string">"href"</span>: <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码表示，文档有一个<code>link</code>属性，用户读这个属性就知道下一步该调用什么<code>API</code>了。<code>rel</code>表示这个<code>API</code>与当前网址的关系，<code>href</code>表示<code>API</code>的路径，<code>title</code>表示<code>API</code>的标题，<code>type</code>表示返回类型。</p><p><code>Hypermedia API</code>的设计被称为<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a>。<code>Github</code>的<code>API</code>就是这种设计，访问<code>api.github.com</code>会得到一个所有可用<code>API</code>的网址列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    “current_user_url”： <span class="string">"https://api.github.com/user"</span>，</span><br><span class="line">    “current_user_authorizations_html_url”： <span class="string">"https://github.com/setti…applications&#123;/client_id&#125;"</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<code>api.github.com/user</code>，然后就得到下面结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"message"</span>:  <span class="string">"Requires authentication"</span>,</span><br><span class="line">    <span class="string">"documentation_url"</span>:    <span class="string">"https://developer.github.com/v3/users/#get-the-authenticated-user"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>API的身份认证应该使用OAuth 2.0框架.</li><li>服务器返回的数据格式，应该尽量使用JSON，避免使用XML.</li></ol><p>参考资料：<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">restful api设计</a></p>]]></content>
    
    <summary type="html">
    
      RESTful API是目前较成熟的一套互联网应用程序API设计理论；这里主要介绍下如何通过RESTful API设计出一套合理好用的API接口。
    
    </summary>
    
      <category term="URL" scheme="http://yoursite.com/categories/URL/"/>
    
    
      <category term="RESTful-api" scheme="http://yoursite.com/tags/RESTful-api/"/>
    
  </entry>
  
  <entry>
    <title>python的多线程</title>
    <link href="http://yoursite.com/2018/09/30/thread/"/>
    <id>http://yoursite.com/2018/09/30/thread/</id>
    <published>2018-09-30T12:59:58.100Z</published>
    <updated>2018-09-30T12:59:58.040Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要执行同时执行多任务时，一般情况下我们会考虑多线程。</p><p><code>Python</code>标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，而<code>threading</code>是对<code>_thread</code>的封装。绝大多数下我们都会使用<code>threading</code>模块。</p><p>下面是一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(n ,int)</span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    print(<span class="string">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">'thread %s --&gt; %s'</span> % (threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s end.'</span> % threading.current_thread().name)</span><br><span class="line">        </span><br><span class="line">print(<span class="string">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=text, args=(<span class="number">5</span>,), name=<span class="string">'ChildThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s end.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread <span class="keyword">is</span> running</span><br><span class="line">thread ChildThread <span class="keyword">is</span> running</span><br><span class="line">thread ChildThread --&gt; 0</span><br><span class="line">thread ChildThread --&gt; 1</span><br><span class="line">thread ChildThread --&gt; 2</span><br><span class="line">thread ChildThread --&gt; 3</span><br><span class="line">thread ChildThread --&gt; 4</span><br><span class="line">thread ChildThread end.</span><br><span class="line">thread MainThread end.</span><br></pre></td></tr></table></figure></p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>对于多线程来说，往往有个弊端：所有变量都是由所有线程共享的，所以任何一个变量都可以被任何一个线程修改，如果同一时间修改同一变量，结果就会混乱。如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bank_money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_money</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> bank_money</span><br><span class="line">    bank_money = bank_money + count</span><br><span class="line">    bank_money = bank_money - count</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_num</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        change_money(count)</span><br><span class="line">        </span><br><span class="line">t1 = threading.Thread(target=do_num, args(<span class="number">100</span>,))</span><br><span class="line">t2 = threading.Thread(target=do_num, args(<span class="number">84</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(bank_money)</span><br></pre></td></tr></table></figure></p><p>这个例子不是很恰当，但是它能很好的表达出多线程的这种弊端：当<code>t1</code>和<code>t2</code>两个线程交替执行是，只要循环次数足够多，最终<code>bank_money</code>的结果不一定是<code>0</code>了。</p><p>为了解决这个问题我们要给<code>change_money()</code>加锁：当某个线程开始执行<code>change_money()</code>时，该线程即获得了锁，其他线程只能等待该线程执行完后，释放锁之后才能执行<code>change_money()</code>函数，这样就不会造成冲突。实例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bank_money = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_num</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 获取锁</span></span><br><span class="line">        locak.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change_money(count)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># 异常处理</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放锁</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure></p><p><code>do_num()</code>函数进行了以上更改，其他代码不变，这样执行最终结果扔会是<code>0</code>。需要注意的是，锁一定要释放，否则程序会进行不下去。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><code>Python</code>的线程虽然是真正的线程，但解释器执行代码时，有一个<code>GIL</code>锁：<code>Global Interpreter Lock</code>，任何<code>Python</code>线程执行前，必须先获得<code>GIL</code>锁，然后，每执行100条字节码，解释器就自动释放<code>GIL</code>锁，让别的线程有机会执行。这个<code>GIL</code>全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在<code>Python</code>中只能交替执行，即使100个线程跑在100核<code>CPU</code>上，也只能用到1个核。</p><p><code>GIL</code>是<code>Python</code>解释器设计的历史遗留问题，通常我们用的解释器是官方实现的<code>CPython</code>，要真正利用多核，除非重写一个不带<code>GIL</code>的解释器。</p><p>所以，在<code>Python</code>中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过<code>C</code>扩展来实现，不过这样就失去了<code>Python</code>简单易用的特点。</p><p>不过，也不用过于担心，<code>Python</code>虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个<code>Python</code>进程有各自独立的<code>GIL</code>锁，互不影响。</p><p>参考资料 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192823818768cd506abbc94eb5916192364506fa5d000#0" target="_blank" rel="noopener">多线程-廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      多线程往往是程序中较长使用的内容。python的多线程往往多需要怎么使用呢？这里主要介绍下python中多线程的使用方法及注意事项。仅供参考。
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Celery的介绍</title>
    <link href="http://yoursite.com/2018/09/29/celery/"/>
    <id>http://yoursite.com/2018/09/29/celery/</id>
    <published>2018-09-29T13:23:19.060Z</published>
    <updated>2018-09-29T13:23:19.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Celery"><a href="#什么是Celery" class="headerlink" title="什么是Celery?"></a>什么是Celery?</h2><p>&emsp;&emsp;<code>Celery</code>是一个简单、灵活可靠、能处理大量消息的分布式系统。它是一个专注于实时处理的任务队列，并且也支持任务调度。<code>Celery</code>有广泛的用户与贡献者社区，而且是开源的，使用 <code>BSD许可证</code> 授权。<br>何为任务队列</p><p>&emsp;&emsp;任务队列是一种在线程或机器间分发任务的机制。</p><p>&emsp;&emsp;消息队列的输入是工作的一个单元，成为任务，独立的职程(worker)进程持续监视队列中是否有需要处理的新任务。</p><p>&emsp;&emsp;<code>Celery</code>用消息通信，通常使用中间人(broker)在客户端和职程间斡旋。这个过程从客户端向队列现价消息开始，之后中间人把消息派送给职程。</p><p>&emsp;&emsp;<code>Celery</code>系统可包含多个职程和中间人，以此获得高可用和横向扩展能力。</p><p>&emsp;&emsp;<code>Celery</code>是用<code>Python</code>编写的，但协议可以用任何语言实现。迄今，已有<code>Ruby</code>实现的<code>RCelery</code>、<code>node.js</code>实现的<code>node-celery</code>以及一个<code>PHP</code>客户端，语言互通也可以通过<code>using webhooks</code>实现。</p><p><code>celery</code>工作流程图如下：<br><img src="/images/celery.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以从<code>Python Package Index(PyPI)</code>或源码安装<code>Celery</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U Celery</span><br><span class="line">或</span><br><span class="line">$ easy_install -U Celery</span><br></pre></td></tr></table></figure></p><p>源码安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvfz celery-0.0.0.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> celery-0.0.0</span><br><span class="line">$ python setup.py build</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></p><p><em>注：如果不是在virtualenv里安装，最后一条命令必须以管理员权限执行。</em></p><h2 id="Celery的优点"><a href="#Celery的优点" class="headerlink" title="Celery的优点"></a>Celery的优点</h2><ol><li><p>简单<br> Celery易于使用和维护，并且它不需要配置文件。下面是一个你可以实现的最简应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'hello'</span>, broker=<span class="string">'amgp://guest@localhost//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></li><li><p>高可用性<br> 倘若连接丢失或失败，职程和客户端自动重试，并且一些中间人通过主/主 或 主/从 方式复制来提高可用性。</p></li><li><p>快速<br> 单个Celery进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级。</p></li><li><p>灵活<br> Celery几乎所有部分都可以扩展或单独使用。可以自制连接池、序列化、压缩模式、日志、调度器、消费者、生产者、自动扩展、中间人传输或更多。<br>Celery支持</p></li><li><p>中间人</p></li></ol><ul><li>RabbitMQ, Redis</li><li>MongoDB(实验性), ZwroMQ(实验性)</li><li>CouchDB(实验性), SQLAlchemy(实验性)</li><li>Django ORM(实验性), Amazon SQS(实验性)</li><li>还有更多…</li></ul><ol start="2"><li>并发</li></ol><ul><li>prefork(多进程)</li><li>Eventlet, gevent</li><li>多线程/单线程</li></ul><ol start="3"><li>结果存储</li></ol><ul><li>AMQP, Redis</li><li>memcached, MongoDB</li><li>SQLAlchemy, Django ORM</li><li>Apache Cassandra</li></ul><ol start="4"><li>序列化</li></ol><ul><li>pickle, json, yaml, msgpack</li><li>zlib, bzip2压缩</li><li>密码学消息签名</li></ul><h2 id="框架继承"><a href="#框架继承" class="headerlink" title="框架继承"></a>框架继承</h2><p>Celery通常与Web框架继承，其中的一些甚至已经有了集成包：</p><table><thead><tr><th>框架</th><th>名称</th></tr></thead><tbody><tr><td>Django</td><td>django-celery</td></tr><tr><td>Pyramid</td><td>pyramid_celery</td></tr><tr><td>Pylons</td><td>celery-pylons</td></tr><tr><td>Flask</td><td>不需要</td></tr><tr><td>web2py</td><td>web2py-celery</td></tr><tr><td>Tornado</td><td>tornado-celery</td></tr></tbody></table><p>继承包并非是严格必要的，但他们让开发更简便。</p><h2 id="中间人-非实验性"><a href="#中间人-非实验性" class="headerlink" title="中间人(非实验性)"></a>中间人(非实验性)</h2><h3 id="使用-RabbitMQ"><a href="#使用-RabbitMQ" class="headerlink" title="使用 RabbitMQ"></a>使用 RabbitMQ</h3><ol><li><p>安装与配置<br><code>RabbitMQ</code>是默认的中间人，所以除了需要你要使用的中间人实例的 <code>URL</code> 位置，它并不需要任何额外的依赖或起始配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'amqp://gueest:guest@localhost:5672//'</span></span><br></pre></td></tr></table></figure><p> <code>Celery</code> 中间人 <code>URL</code> 的描述和完整的中间人可用配置选项列表见 <a href="http://docs.jinkan.org/docs/celery/configuration.html#conf-broker-settings" target="_blank" rel="noopener">Broker Settings</a> </p></li><li><p>安装 <code>RabbitMQ</code> 服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rabbitmq-server</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>RabbitMQ</code><br>要使用 <code>Celery</code>，我们需要创建一个 <code>RabbitMQ</code> 用户、一个虚拟主机，并且允许这个用户访问这个虚拟主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user myuser mypassword</span><br><span class="line">sudo rabbitmqctl add_vhost myvhost</span><br><span class="line">sudo rabbitmqctl set_permissions -p myvhost myuser <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-Redis"><a href="#使用-Redis" class="headerlink" title="使用 Redis"></a>使用 Redis</h3><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install redis-server</span><br><span class="line">或</span><br><span class="line">pip install -U celery[redis]</span><br></pre></td></tr></table></figure></li><li><p>配置<br>配置非常简单，只需要设置 <code>Redis</code> 数据库的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'redis://localhost:6379/0'</span></span><br></pre></td></tr></table></figure><p>URL 的各式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis://:password@hostname:port/db_number</span><br></pre></td></tr></table></figure></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>首先你需要一个<code>Celery</code>实例，成为<code>Celery</code>应用或直接简称应用。既然这个实例用于你想在<code>Celery</code>中做的一切事——比如创建任务、管理职程的入口点，它必须可以被其他模块导入。</p><p>在此教程中，你的一切都容纳在单一模块里，对于更大的项目，你会想创建独立模块。</p><p>创建<code>tasks.py</code>，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'amqp://guest@localhost//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p><code>Celery</code>的第一个参数是当前模块的名称，这个参数必须有。第二个参数是中间人关键字参数，指定你所使用的消息中间人的<code>URL</code>，此处使用了<code>RabbitMQ</code>你可以写<code>amqp://localhost</code>，而对于<code>Redis</code>你可以写<code>redis://localhost</code></p><p>你定义了一个单一<code>add</code>任务，返回两个数的和。</p><h2 id="运行Celery职程服务器"><a href="#运行Celery职程服务器" class="headerlink" title="运行Celery职程服务器"></a>运行<code>Celery</code>职程服务器</h2><p>你现在可以用<code>worker</code>参数执行我们的程序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker --loglevel=info</span><br></pre></td></tr></table></figure></p><h2 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h2><p>你可以用<code>delay()</code>方法来调用任务。</p><p>这是<code>apply_async()</code>方法的快捷方式，该方法允许你更好地控制任务执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from tasks import add</span><br><span class="line">&gt;&gt;&gt; add.delay(4, 4)</span><br></pre></td></tr></table></figure></p><h2 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h2><p>如果你想要保持追踪任务的状态，<code>Celery</code>需要在某个地方存储或者发送这些状态。可以从内建的几个结果后端选择：<code>SQLAlchemy/Django ORM</code>、<code>Memcached</code>、<code>Redis</code>、<code>AMQP(RabbitMQ)</code>或<code>MongoDB</code>，或者你可以自制。如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Celery(<span class="string">'tasks'</span>, backed=<span class="string">'amqp'</span>, broker=<span class="string">'amqp://'</span>)</span><br></pre></td></tr></table></figure></p><p>或者如果你想要把<code>Redis</code>用作结果后端，但仍然用<code>RabbitMQ</code>作为消息中间人：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Celery(<span class="string">'tasks'</span>, backend=<span class="string">'redis://localhost'</span>, broker=<span class="string">'amqp://'</span>)</span><br></pre></td></tr></table></figure></p><p>调用任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p><code>read()</code>方法查看任务是否完成处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>更多信息请参照 <a href="http://docs.jinkan.org/docs/celery/" target="_blank" rel="noopener">Celery文档</a></p>]]></content>
    
    <summary type="html">
    
      Celery是一个简单、灵活可靠、能处理大量消息的分布式系统。它是一个专注于实时处理的任务队列，并且也支持任务调度。Celery有广泛的用户与贡献者社区，而且是开源的，使用 BSD许可证 授权。
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="celery" scheme="http://yoursite.com/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>nginx的使用</title>
    <link href="http://yoursite.com/2018/09/28/nginx/"/>
    <id>http://yoursite.com/2018/09/28/nginx/</id>
    <published>2018-09-28T14:47:47.889Z</published>
    <updated>2018-09-28T14:47:47.849Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx?"></a>什么是Nginx?</h4><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡；支持高并发，并且消耗资源非常低，运行非常稳定。</p><p>由于nginx的优点，促使它快速成为使用广泛的http服务器，这里主要介绍一下nginx的使用及配置(ubuntu下)。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><p>nginx安装完后，默认时启动的，可以通过：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep nginx</span><br></pre></td></tr></table></figure></p><p>来查看nginx是否启动。如果是下面这种情况即是启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root       881  0.0  0.0 140620  1512 ?        Ss   20:12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data   882  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   883  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   884  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   885  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">mistack+  5146  0.0  0.0  21536  1088 pts/0    S+   20:53   0:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure></p><p>如果没有启动，可通过下面命令来启动，已启动可重启、或停止：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx start    <span class="comment"># 启动</span></span><br><span class="line">sudo /etc/init.d/nginx restart    <span class="comment"># 重启</span></span><br><span class="line">sudo /etc/init.d/nginx stop    <span class="comment"># 停止</span></span><br></pre></td></tr></table></figure></p><p>打开浏览器，访问localhost，可以看到如下内容：<br><img src="/images/nginx.png" alt=""><br>即nginx安装并启动成功。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx默认配置文件在 <code>/etc/nginx/conf.d/default.conf</code>。我们可以删除默认配置文件在该文件夹下新建一个 <code>nginx.conf</code> 的配置文件。由于nginx支持的功能很多，我们逐一配置，皆存放在<code>nginx.conf</code>中。每次更改了配置信息，需要重新启动nginx服务器才能生效。</p><h3 id="静态http服务器"><a href="#静态http服务器" class="headerlink" title="静态http服务器"></a>静态http服务器</h3><blockquote><p>ngin可以将服务器上的静态文件，通过http协议展现给客户端浏览器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;    <span class="comment"># 监听端口</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;    <span class="comment"># 静态文件路径，也是默认路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><blockquote><p>nginx可以实现反向代理，客户端可以访问nginx，然后由nginx去访问web服务器，把服务器返回的数据再返回给客户端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;    <span class="comment"># 监听端口</span></span><br><span class="line">    location / &#123;</span><br><span class="line">proxy_pass http://192.168.0.100:8000;  <span class="comment"># 应用服务器HTTP地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><blockquote><p>当一个网站有很多访问量时，一台服务器往往会压力过大，容易崩溃；为了解决这个问题，nginx提供了负载均衡—-即配置多个相同的服务器分担压力，一旦其中一个挂掉，页不会影响用户的访问。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream app &#123;</span><br><span class="line">    server    192.168.0.100:8000;    <span class="comment"># 服务器1</span></span><br><span class="line">    server    192.168.0.200:8000;    <span class="comment"># 服务器2</span></span><br><span class="line">    server    192.168.0.250:8000;    <span class="comment"># 服务器3</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><blockquote><p>有的网站，访问量不多，而要节约成本，需要将多个网站部署到同一台服务器上。这种技术叫做虚拟主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    www.aaa.com;    <span class="comment"># www.aaa.com域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    www.bbb.com;    <span class="comment"># www.bbb.com域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8001;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h3><blockquote><p>nginx本身不支持动态网页，但是它可以通过uwsgi来将请求扔给某些语言或框架处理(例如：PHP/Python/Perl等)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream  app &#123;</span><br><span class="line">    server localhost:5000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    127.0.0.1;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_read_timeout    3600;</span><br><span class="line">        uwsgi_pass    app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>更多配置信息请见 <a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">Nginx中文文档</a></p>]]></content>
    
    <summary type="html">
    
      nginx作为web服务器时下还是非常流行的，主要介绍下nginx的常用配置。如需更多配置设置，请详阅官方文档。
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>测试test文件</title>
    <link href="http://yoursite.com/2018/09/27/test/"/>
    <id>http://yoursite.com/2018/09/27/test/</id>
    <published>2018-09-27T12:51:41.481Z</published>
    <updated>2018-09-27T12:51:41.449Z</updated>
    
    <content type="html"><![CDATA[<p>这是测试内容</p><blockquote><p>先看看这个是否有效果显示<br>该文章是开启评论的</p></blockquote><p>这是运行的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python3</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这是该测试页面的描述，随便写的东西，只是为了让页面显示，看其作用。
    
    </summary>
    
    
  </entry>
  
</feed>
