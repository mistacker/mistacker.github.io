<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mistacker|博客</title>
  
  <subtitle>孤帆远影碧空尽，唯见长江天际流。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-30T12:59:58.040Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mistacker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python的多线程</title>
    <link href="http://yoursite.com/2018/09/30/thread/"/>
    <id>http://yoursite.com/2018/09/30/thread/</id>
    <published>2018-09-30T12:59:58.100Z</published>
    <updated>2018-09-30T12:59:58.040Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要执行同时执行多任务时，一般情况下我们会考虑多线程。</p><p><code>Python</code>标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，而<code>threading</code>是对<code>_thread</code>的封装。绝大多数下我们都会使用<code>threading</code>模块。</p><p>下面是一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(n ,int)</span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    print(<span class="string">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">'thread %s --&gt; %s'</span> % (threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s end.'</span> % threading.current_thread().name)</span><br><span class="line">        </span><br><span class="line">print(<span class="string">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=text, args=(<span class="number">5</span>,), name=<span class="string">'ChildThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s end.'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread <span class="keyword">is</span> running</span><br><span class="line">thread ChildThread <span class="keyword">is</span> running</span><br><span class="line">thread ChildThread --&gt; 0</span><br><span class="line">thread ChildThread --&gt; 1</span><br><span class="line">thread ChildThread --&gt; 2</span><br><span class="line">thread ChildThread --&gt; 3</span><br><span class="line">thread ChildThread --&gt; 4</span><br><span class="line">thread ChildThread end.</span><br><span class="line">thread MainThread end.</span><br></pre></td></tr></table></figure></p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>对于多线程来说，往往有个弊端：所有变量都是由所有线程共享的，所以任何一个变量都可以被任何一个线程修改，如果同一时间修改同一变量，结果就会混乱。如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bank_money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_money</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> bank_money</span><br><span class="line">    bank_money = bank_money + count</span><br><span class="line">    bank_money = bank_money - count</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_num</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        change_money(count)</span><br><span class="line">        </span><br><span class="line">t1 = threading.Thread(target=do_num, args(<span class="number">100</span>,))</span><br><span class="line">t2 = threading.Thread(target=do_num, args(<span class="number">84</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(bank_money)</span><br></pre></td></tr></table></figure></p><p>这个例子不是很恰当，但是它能很好的表达出多线程的这种弊端：当<code>t1</code>和<code>t2</code>两个线程交替执行是，只要循环次数足够多，最终<code>bank_money</code>的结果不一定是<code>0</code>了。</p><p>为了解决这个问题我们要给<code>change_money()</code>加锁：当某个线程开始执行<code>change_money()</code>时，该线程即获得了锁，其他线程只能等待该线程执行完后，释放锁之后才能执行<code>change_money()</code>函数，这样就不会造成冲突。实例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bank_money = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_num</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 获取锁</span></span><br><span class="line">        locak.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change_money(count)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># 异常处理</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放锁</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure></p><p><code>do_num()</code>函数进行了以上更改，其他代码不变，这样执行最终结果扔会是<code>0</code>。需要注意的是，锁一定要释放，否则程序会进行不下去。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><code>Python</code>的线程虽然是真正的线程，但解释器执行代码时，有一个<code>GIL</code>锁：<code>Global Interpreter Lock</code>，任何<code>Python</code>线程执行前，必须先获得<code>GIL</code>锁，然后，每执行100条字节码，解释器就自动释放<code>GIL</code>锁，让别的线程有机会执行。这个<code>GIL</code>全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在<code>Python</code>中只能交替执行，即使100个线程跑在100核<code>CPU</code>上，也只能用到1个核。</p><p><code>GIL</code>是<code>Python</code>解释器设计的历史遗留问题，通常我们用的解释器是官方实现的<code>CPython</code>，要真正利用多核，除非重写一个不带<code>GIL</code>的解释器。</p><p>所以，在<code>Python</code>中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过<code>C</code>扩展来实现，不过这样就失去了<code>Python</code>简单易用的特点。</p><p>不过，也不用过于担心，<code>Python</code>虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个<code>Python</code>进程有各自独立的<code>GIL</code>锁，互不影响。</p><p>参考资料 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143192823818768cd506abbc94eb5916192364506fa5d000#0" target="_blank" rel="noopener">多线程-廖雪峰的官方网站</a></p>]]></content>
    
    <summary type="html">
    
      多线程往往是程序中较长使用的内容。python的多线程往往多需要怎么使用呢？这里主要介绍下python中多线程的使用方法及注意事项。仅供参考。
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Celery的介绍</title>
    <link href="http://yoursite.com/2018/09/29/celery/"/>
    <id>http://yoursite.com/2018/09/29/celery/</id>
    <published>2018-09-29T13:23:19.060Z</published>
    <updated>2018-09-29T13:23:19.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Celery"><a href="#什么是Celery" class="headerlink" title="什么是Celery?"></a>什么是Celery?</h2><p>&emsp;&emsp;<code>Celery</code>是一个简单、灵活可靠、能处理大量消息的分布式系统。它是一个专注于实时处理的任务队列，并且也支持任务调度。<code>Celery</code>有广泛的用户与贡献者社区，而且是开源的，使用 <code>BSD许可证</code> 授权。<br>何为任务队列</p><p>&emsp;&emsp;任务队列是一种在线程或机器间分发任务的机制。</p><p>&emsp;&emsp;消息队列的输入是工作的一个单元，成为任务，独立的职程(worker)进程持续监视队列中是否有需要处理的新任务。</p><p>&emsp;&emsp;<code>Celery</code>用消息通信，通常使用中间人(broker)在客户端和职程间斡旋。这个过程从客户端向队列现价消息开始，之后中间人把消息派送给职程。</p><p>&emsp;&emsp;<code>Celery</code>系统可包含多个职程和中间人，以此获得高可用和横向扩展能力。</p><p>&emsp;&emsp;<code>Celery</code>是用<code>Python</code>编写的，但协议可以用任何语言实现。迄今，已有<code>Ruby</code>实现的<code>RCelery</code>、<code>node.js</code>实现的<code>node-celery</code>以及一个<code>PHP</code>客户端，语言互通也可以通过<code>using webhooks</code>实现。</p><p><code>celery</code>工作流程图如下：<br><img src="/images/celery.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以从<code>Python Package Index(PyPI)</code>或源码安装<code>Celery</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U Celery</span><br><span class="line">或</span><br><span class="line">$ easy_install -U Celery</span><br></pre></td></tr></table></figure></p><p>源码安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar xvfz celery-0.0.0.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> celery-0.0.0</span><br><span class="line">$ python setup.py build</span><br><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure></p><p><em>注：如果不是在virtualenv里安装，最后一条命令必须以管理员权限执行。</em></p><h2 id="Celery的优点"><a href="#Celery的优点" class="headerlink" title="Celery的优点"></a>Celery的优点</h2><ol><li><p>简单<br> Celery易于使用和维护，并且它不需要配置文件。下面是一个你可以实现的最简应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'hello'</span>, broker=<span class="string">'amgp://guest@localhost//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></li><li><p>高可用性<br> 倘若连接丢失或失败，职程和客户端自动重试，并且一些中间人通过主/主 或 主/从 方式复制来提高可用性。</p></li><li><p>快速<br> 单个Celery进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级。</p></li><li><p>灵活<br> Celery几乎所有部分都可以扩展或单独使用。可以自制连接池、序列化、压缩模式、日志、调度器、消费者、生产者、自动扩展、中间人传输或更多。<br>Celery支持</p></li><li><p>中间人</p></li></ol><ul><li>RabbitMQ, Redis</li><li>MongoDB(实验性), ZwroMQ(实验性)</li><li>CouchDB(实验性), SQLAlchemy(实验性)</li><li>Django ORM(实验性), Amazon SQS(实验性)</li><li>还有更多…</li></ul><ol start="2"><li>并发</li></ol><ul><li>prefork(多进程)</li><li>Eventlet, gevent</li><li>多线程/单线程</li></ul><ol start="3"><li>结果存储</li></ol><ul><li>AMQP, Redis</li><li>memcached, MongoDB</li><li>SQLAlchemy, Django ORM</li><li>Apache Cassandra</li></ul><ol start="4"><li>序列化</li></ol><ul><li>pickle, json, yaml, msgpack</li><li>zlib, bzip2压缩</li><li>密码学消息签名</li></ul><h2 id="框架继承"><a href="#框架继承" class="headerlink" title="框架继承"></a>框架继承</h2><p>Celery通常与Web框架继承，其中的一些甚至已经有了集成包：</p><table><thead><tr><th>框架</th><th>名称</th></tr></thead><tbody><tr><td>Django</td><td>django-celery</td></tr><tr><td>Pyramid</td><td>pyramid_celery</td></tr><tr><td>Pylons</td><td>celery-pylons</td></tr><tr><td>Flask</td><td>不需要</td></tr><tr><td>web2py</td><td>web2py-celery</td></tr><tr><td>Tornado</td><td>tornado-celery</td></tr></tbody></table><p>继承包并非是严格必要的，但他们让开发更简便。</p><h2 id="中间人-非实验性"><a href="#中间人-非实验性" class="headerlink" title="中间人(非实验性)"></a>中间人(非实验性)</h2><h3 id="使用-RabbitMQ"><a href="#使用-RabbitMQ" class="headerlink" title="使用 RabbitMQ"></a>使用 RabbitMQ</h3><ol><li><p>安装与配置<br><code>RabbitMQ</code>是默认的中间人，所以除了需要你要使用的中间人实例的 <code>URL</code> 位置，它并不需要任何额外的依赖或起始配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'amqp://gueest:guest@localhost:5672//'</span></span><br></pre></td></tr></table></figure><p> <code>Celery</code> 中间人 <code>URL</code> 的描述和完整的中间人可用配置选项列表见 <a href="http://docs.jinkan.org/docs/celery/configuration.html#conf-broker-settings" target="_blank" rel="noopener">Broker Settings</a> </p></li><li><p>安装 <code>RabbitMQ</code> 服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rabbitmq-server</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>RabbitMQ</code><br>要使用 <code>Celery</code>，我们需要创建一个 <code>RabbitMQ</code> 用户、一个虚拟主机，并且允许这个用户访问这个虚拟主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user myuser mypassword</span><br><span class="line">sudo rabbitmqctl add_vhost myvhost</span><br><span class="line">sudo rabbitmqctl set_permissions -p myvhost myuser <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-Redis"><a href="#使用-Redis" class="headerlink" title="使用 Redis"></a>使用 Redis</h3><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install redis-server</span><br><span class="line">或</span><br><span class="line">pip install -U celery[redis]</span><br></pre></td></tr></table></figure></li><li><p>配置<br>配置非常简单，只需要设置 <code>Redis</code> 数据库的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'redis://localhost:6379/0'</span></span><br></pre></td></tr></table></figure><p>URL 的各式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis://:password@hostname:port/db_number</span><br></pre></td></tr></table></figure></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>首先你需要一个<code>Celery</code>实例，成为<code>Celery</code>应用或直接简称应用。既然这个实例用于你想在<code>Celery</code>中做的一切事——比如创建任务、管理职程的入口点，它必须可以被其他模块导入。</p><p>在此教程中，你的一切都容纳在单一模块里，对于更大的项目，你会想创建独立模块。</p><p>创建<code>tasks.py</code>，示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'amqp://guest@localhost//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p><code>Celery</code>的第一个参数是当前模块的名称，这个参数必须有。第二个参数是中间人关键字参数，指定你所使用的消息中间人的<code>URL</code>，此处使用了<code>RabbitMQ</code>你可以写<code>amqp://localhost</code>，而对于<code>Redis</code>你可以写<code>redis://localhost</code></p><p>你定义了一个单一<code>add</code>任务，返回两个数的和。</p><h2 id="运行Celery职程服务器"><a href="#运行Celery职程服务器" class="headerlink" title="运行Celery职程服务器"></a>运行<code>Celery</code>职程服务器</h2><p>你现在可以用<code>worker</code>参数执行我们的程序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker --loglevel=info</span><br></pre></td></tr></table></figure></p><h2 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h2><p>你可以用<code>delay()</code>方法来调用任务。</p><p>这是<code>apply_async()</code>方法的快捷方式，该方法允许你更好地控制任务执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from tasks import add</span><br><span class="line">&gt;&gt;&gt; add.delay(4, 4)</span><br></pre></td></tr></table></figure></p><h2 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h2><p>如果你想要保持追踪任务的状态，<code>Celery</code>需要在某个地方存储或者发送这些状态。可以从内建的几个结果后端选择：<code>SQLAlchemy/Django ORM</code>、<code>Memcached</code>、<code>Redis</code>、<code>AMQP(RabbitMQ)</code>或<code>MongoDB</code>，或者你可以自制。如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Celery(<span class="string">'tasks'</span>, backed=<span class="string">'amqp'</span>, broker=<span class="string">'amqp://'</span>)</span><br></pre></td></tr></table></figure></p><p>或者如果你想要把<code>Redis</code>用作结果后端，但仍然用<code>RabbitMQ</code>作为消息中间人：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Celery(<span class="string">'tasks'</span>, backend=<span class="string">'redis://localhost'</span>, broker=<span class="string">'amqp://'</span>)</span><br></pre></td></tr></table></figure></p><p>调用任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p><code>read()</code>方法查看任务是否完成处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>更多信息请参照 <a href="http://docs.jinkan.org/docs/celery/" target="_blank" rel="noopener">Celery文档</a></p>]]></content>
    
    <summary type="html">
    
      Celery是一个简单、灵活可靠、能处理大量消息的分布式系统。它是一个专注于实时处理的任务队列，并且也支持任务调度。Celery有广泛的用户与贡献者社区，而且是开源的，使用 BSD许可证 授权。
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="celery" scheme="http://yoursite.com/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>nginx的使用</title>
    <link href="http://yoursite.com/2018/09/28/nginx/"/>
    <id>http://yoursite.com/2018/09/28/nginx/</id>
    <published>2018-09-28T14:47:47.889Z</published>
    <updated>2018-09-28T14:47:47.849Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx?"></a>什么是Nginx?</h4><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡；支持高并发，并且消耗资源非常低，运行非常稳定。</p><p>由于nginx的优点，促使它快速成为使用广泛的http服务器，这里主要介绍一下nginx的使用及配置(ubuntu下)。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><p>nginx安装完后，默认时启动的，可以通过：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep nginx</span><br></pre></td></tr></table></figure></p><p>来查看nginx是否启动。如果是下面这种情况即是启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root       881  0.0  0.0 140620  1512 ?        Ss   20:12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data   882  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   883  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   884  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">www-data   885  0.0  0.0 143240  6252 ?        S    20:12   0:00 nginx: worker process</span><br><span class="line">mistack+  5146  0.0  0.0  21536  1088 pts/0    S+   20:53   0:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure></p><p>如果没有启动，可通过下面命令来启动，已启动可重启、或停止：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx start    <span class="comment"># 启动</span></span><br><span class="line">sudo /etc/init.d/nginx restart    <span class="comment"># 重启</span></span><br><span class="line">sudo /etc/init.d/nginx stop    <span class="comment"># 停止</span></span><br></pre></td></tr></table></figure></p><p>打开浏览器，访问localhost，可以看到如下内容：<br><img src="/images/nginx.png" alt=""><br>即nginx安装并启动成功。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx默认配置文件在 <code>/etc/nginx/conf.d/default.conf</code>。我们可以删除默认配置文件在该文件夹下新建一个 <code>nginx.conf</code> 的配置文件。由于nginx支持的功能很多，我们逐一配置，皆存放在<code>nginx.conf</code>中。每次更改了配置信息，需要重新启动nginx服务器才能生效。</p><h3 id="静态http服务器"><a href="#静态http服务器" class="headerlink" title="静态http服务器"></a>静态http服务器</h3><blockquote><p>ngin可以将服务器上的静态文件，通过http协议展现给客户端浏览器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;    <span class="comment"># 监听端口</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html;    <span class="comment"># 静态文件路径，也是默认路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><blockquote><p>nginx可以实现反向代理，客户端可以访问nginx，然后由nginx去访问web服务器，把服务器返回的数据再返回给客户端。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;    <span class="comment"># 监听端口</span></span><br><span class="line">    location / &#123;</span><br><span class="line">proxy_pass http://192.168.0.100:8000;  <span class="comment"># 应用服务器HTTP地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><blockquote><p>当一个网站有很多访问量时，一台服务器往往会压力过大，容易崩溃；为了解决这个问题，nginx提供了负载均衡—-即配置多个相同的服务器分担压力，一旦其中一个挂掉，页不会影响用户的访问。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream app &#123;</span><br><span class="line">    server    192.168.0.100:8000;    <span class="comment"># 服务器1</span></span><br><span class="line">    server    192.168.0.200:8000;    <span class="comment"># 服务器2</span></span><br><span class="line">    server    192.168.0.250:8000;    <span class="comment"># 服务器3</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><blockquote><p>有的网站，访问量不多，而要节约成本，需要将多个网站部署到同一台服务器上。这种技术叫做虚拟主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    www.aaa.com;    <span class="comment"># www.aaa.com域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    www.bbb.com;    <span class="comment"># www.bbb.com域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8001;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h3><blockquote><p>nginx本身不支持动态网页，但是它可以通过uwsgi来将请求扔给某些语言或框架处理(例如：PHP/Python/Perl等)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream  app &#123;</span><br><span class="line">    server localhost:5000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen    80;</span><br><span class="line">    server_name    127.0.0.1;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_read_timeout    3600;</span><br><span class="line">        uwsgi_pass    app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>更多配置信息请见 <a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">Nginx中文文档</a></p>]]></content>
    
    <summary type="html">
    
      nginx作为web服务器时下还是非常流行的，主要介绍下nginx的常用配置。如需更多配置设置，请详阅官方文档。
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>测试test文件</title>
    <link href="http://yoursite.com/2018/09/27/test/"/>
    <id>http://yoursite.com/2018/09/27/test/</id>
    <published>2018-09-27T12:51:41.481Z</published>
    <updated>2018-09-27T12:51:41.449Z</updated>
    
    <content type="html"><![CDATA[<p>这是测试内容</p><blockquote><p>先看看这个是否有效果显示<br>该文章是开启评论的</p></blockquote><p>这是运行的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python3</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这是该测试页面的描述，随便写的东西，只是为了让页面显示，看其作用。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/09/27/hello-world/"/>
    <id>http://yoursite.com/2018/09/27/hello-world/</id>
    <published>2018-09-27T08:49:33.590Z</published>
    <updated>2018-09-27T08:49:33.562Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
